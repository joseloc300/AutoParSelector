import clava.autopar.Parallelize;
import clava.autopar.ParallelizeLoop;
import lara.Io;
import lara.util.LocalFolder;
import clava.ClavaJoinPoints;
import lara.cmake.CMaker;
import weaver.util.WeaverDataStore;
import lara.code.Timer;
import lara.metrics.ExecutionTimeMetric;
import weaver.Query;
import lara.Strings;

import CustomExecutionTimeMetric;
import CustomParallelize;

var now;

aspectdef Polybench
	input
		sourceFolder,
		benchmarkFolders
	end

	now = new Date(Date.now());

	var polybenchResults = {};
	var nRuns = 3;

	var benchmarks = getSubFolders(sourceFolder, benchmarkFolders);

	var polybenchUtilsFolder = Io.getAbsolutePath(sourceFolder + "utilities/");
	var polybenchCPath = Io.getPath(polybenchUtilsFolder, "polybench.c");

	println("Number of benchmarks found: " + benchmarks.length);
	println("Processing benchmarks");
	for (var benchmark of benchmarks) {
		println("Processing: " + benchmark.folder);

		Clava.pushAst();
		rebuildCodeAst(polybenchUtilsFolder, polybenchCPath, benchmark);
		Clava.pushAst();

		var benchmarkResults = {};
		benchmarkResults["par"] = {};
		benchmarkResults["par"]["nVersions"] = 0;
		benchmarkResults["par"]["versions"] = [];
		benchmarkResults["seq"] = {};

		var loopToIndex = {};

		var parLoops = getParLoops();
		addLoopInfo(parLoops, benchmarkResults, loopToIndex);
		printObject(benchmarkResults);
		println("a");
		printObject(loopToIndex);
		println("a");
		var parLoopGroups = getParLoopGroups(parLoops);
		Clava.popAst();

		var version = 0;
		for (var loopGroup of parLoopGroups) {
			Clava.pushAst();

			//Parallelize.forLoops([loop]);
			CustomParallelize.forLoops(loopGroup);
						
			var measuresPar = addTimerPar(loopGroup, loopToIndex);
			//var compoundId = getCompoundId(loopGroup);
			//var executorsPar = buildAndRun(benchmark, compoundId, nRuns, true);
			var executorsPar = buildAndRun(benchmark, version, nRuns, true);
			var loopIndexes = getLoopIndexes(loopGroup, loopToIndex);
			addResults(benchmarkResults, measuresPar, executorsPar, true, loopIndexes, version);
			version++;
			Clava.popAst();
		}

		
		
		var parLoopIds = getParLoopIds(parLoops);

		var measuresSeq = addTimerSeq(parLoopIds, loopToIndex);
		var executorsSeq = buildAndRun(benchmark, version, nRuns, false);	
		addResults(benchmarkResults, measuresSeq, executorsSeq, false, null, null);
		Clava.popAst();
		
		polybenchResults[benchmark.folder] = benchmarkResults;
		Io.writeJson(benchmark.outputFolder + "/results.json", benchmarkResults);
	}

	Io.writeJson("./results/polybench_" + now.toISOString() + ".json", polybenchResults);

end

function getLoopIndexes(loopGroup, loopToIndex) {
	var indexes = [];
	for(var loop of loopGroup) {
		indexes.push(loopToIndex[loop.id]);
	}

	return indexes;
}

function addLoopInfo(parLoops, benchmarkResults, loopToIndex) {
	benchmarkResults["nLoops"] = parLoops.length;
	benchmarkResults["loops"] = {};
	var index = 0;
	for(var $loop of parLoops) {
		benchmarkResults["loops"][index] = {};
		benchmarkResults["loops"][index]["id"] = $loop.id;
		benchmarkResults["loops"][index]["origLine"] = $loop.line;
		benchmarkResults["loops"][index]["iterations"] = $loop.iterations;
		benchmarkResults["loops"][index]["nestedLevel"] = $loop.nestedLevel;
		benchmarkResults["loops"][index]["isInnermost"] = $loop.isInnermost;
		benchmarkResults["loops"][index]["isOutermost"] = $loop.isOutermost;
		benchmarkResults["loops"][index]["rank"] = Array.from($loop.rank);

		var pragmas = [];
		for(var $pragma of $loop.pragmas) {
			pragmas.push($pragma.code);
		}
		
		benchmarkResults["loops"][index]["pragmas"] = pragmas;

		loopToIndex[$loop.id] = index;
		index++;
	}
}

function getCompoundId(loopGroup) {
	var id = "";

	for($loop of loopGroup) {
		id += $loop.id;
	}

	return id;
}

function getParLoopIds(parLoops) {
	var parLoopIds = [];

	for (var loop of parLoops) {
		parLoopIds.push(loop.id);
	}

	return parLoopIds;
}

function addResults(benchmarkResults, measures, executors, isPar, loopIndexes, version) {
	var name = "";
	var info = {};
	if (isPar) {
		name = "par";
		//benchmarkResults[name][version] = {};
		//benchmarkResults[name][version]["parLoops"] = Array.from(loopIndexes);
		benchmarkResults["par"]["nVersions"] += 1;
		info["version"] = version;
		info["parLoops"] = Array.from(loopIndexes);
		info["nRuns"] = executors.length;
		info["measures"] = [];
	}
	else
		name = "seq";


	println("measures.length: " + measures.length);
	println("executors.length: " + executors.length);

	for(var measure of measures) {
		/*
		if(isPar) {
			benchmarkResults[measure._prefix] = {};
		}
		*/
		var measureInfo = {};
		measureInfo["loopIndex"] = measure._prefix;
		measureInfo["runs"] = [];
		var runId = 0;
		if(!isPar)
			benchmarkResults[name][measure._prefix] = {};
		for(var executor of executors) {
			var res = measure.report(executor);
			var newRes = {};
			newRes.value = res.getValue();
			newRes.unit = res.getUnit();
			//println("newRes.value: " + newRes.value);
			//println("newRes.unit: " + newRes.unit);
			if(isPar) {
				//benchmarkResults[name][version][runId] = newRes;
				measureInfo["runs"].push(newRes);
			}
			else {
				benchmarkResults[name][measure._prefix][runId] = newRes;
			}
			runId++;
		}

		if(isPar) {
			info["measures"].push(measureInfo);
		}
	}

	if(isPar) {
		benchmarkResults["par"]["versions"].push(info);
	}
	
}

function getSubFolders(sourceFolder, benchmarkFolders) {
	if (benchmarkFolders.length == 1 && benchmarkFolders[0] == "all")
		benchmarkFolders = ["datamining", "linear-algebra", "medley", "stencils"];

	var benchmarks = [];
	var foldersChecked = [];

	for (var folder of benchmarkFolders) {
		var folderPath = sourceFolder + folder;
		
		if(!Io.isFolder(folderPath)) {
			println(folderPath + " is not a valid folder.");
			continue;
		}

		var folder = new LocalFolder(folderPath);
		var fileList = folder.getFileList();

		for (var file of fileList) {
			var fileString = file.toString();
			if(fileString.slice(-2) != ".c")
				continue;

			var benchmark = createBenchmarkObj(fileString);
			if(foldersChecked.contains(benchmark.folder))
				continue;

			benchmarks.push(benchmark);
			foldersChecked.push(benchmark.folder);

		}
	}
	return benchmarks;
}

function createBenchmarkObj(fileString) {
	var benchmark = new Object();
			
	var lastSlash = fileString.lastIndexOf("/");
	var polyIndex = fileString.indexOf("polybench");
	benchmark.c = Io.getAbsolutePath(fileString);
	benchmark.folder = Io.getAbsolutePath(fileString.slice(0, lastSlash));
	benchmark.outputFolder = Io.getAbsolutePath("./outputs/" + fileString.slice(polyIndex, lastSlash));
	benchmark.name = Io.removeExtension(fileString.substring(lastSlash + 1));

	return benchmark;
}

function rebuildCodeAst(polybenchUtilsFolder, polybenchCPath, benchmark) {
	var dataStore = Clava.getData();
	dataStore.setUserIncludes(polybenchUtilsFolder, benchmark.folder);

	var $polyC = ClavaJoinPoints.file(polybenchCPath);
	var $benchC = ClavaJoinPoints.file(benchmark.c);
	Clava.addFile($polyC);
	Clava.addFile($benchC);

	Clava.rebuild();
}

function addTimerSeq(parallelLoopIds, loopToIndex) {

	var measures = [];

	for(var result of Query.search('function').search('loop').chain()) {
		if(!parallelLoopIds.includes(result["loop"].id)) {
			continue;
		}

		var measure = new CustomExecutionTimeMetric(loopToIndex[result["loop"].id].toString(), false);
		measures.push(measure);
		
		measure.instrument(result["loop"]);
	}

	return measures;
}

function addTimerPar($loopGroup, loopToIndex) {
	var measures = [];

	var astIds = [];

	for(var loop of $loopGroup) {
		astIds.push(loop.astId);
	}
	
	for(var result of Query.search('pragma')) {
		if(result.name != "omp")
			continue;

		/*
		var descendantLoops = result.descendants("loop");
		println("descendantLoops length: " +  descendantLoops.length);
		for(var descendant of descendantLoops) {
			if(descendant.hasNode($loop))
				println("encontrou");
		}
		*/

		var pragmaLoop = result.target;
		if(!astIds.includes(pragmaLoop.astId))
			continue;

		var measure = new CustomExecutionTimeMetric(loopToIndex[result.target.id].toString(), true);
		measures.push(measure);
		
		measure.instrument(result, result.target);
		
	}

	return measures;
}

function getParLoopGroups($parLoops) {
	/*var loops = [];

	for(var result of Query.search('function').search('loop').chain()) {
		// Only time loops inside Polybench kernel functions

		if(!result["function"].name.startsWith("kernel_")) {
			continue;
		}
		
		println(result["loop"].nestedLevel);
		println(result["loop"].iterations);

		loops.push(result["loop"]);
	}

	Parallelize.forLoops(loops);

	var pragmas = Parallelize.getForLoopsPragmas(loops);
	var astIds = Object.keys(pragmas["parallelLoops"]); */

	var $parLoopsLvl0 = [];
	var $parLoopsRest = [];
	for(var $loop of $parLoops) {
		if($loop.nestedLevel == 0) {
			$parLoopsLvl0.push($loop);
		}
		else {
			$parLoopsRest.push($loop);
		}
	}

	//var $orderedLoops = orderByNestLvl($parLoops);
	var $loopGroupsPar = groupParLoops($parLoopsLvl0, $parLoopsRest);
	
	return $loopGroupsPar;
}

function orderByNestLvl($loops) {
	var $orderedLoops = [];
	var counter = 0;
	var lvl = 0;
	
	while(counter != $loops.length) {
		var $currLvlLoops = [];
		for(var i = 0; i < $loops.length; i++) {
			if($loops[i].nestedlevel == lvl) {
				$currLvlLoops.push($loops[i]);
				counter++;
			}
		}
		lvl++;
		$orderedLoops.push($currLvlLoops);
	}

	return $orderedLoops;
}

function getParLoops() {
	var loops = [];

	for(var result of Query.search('function').search('loop').chain()) {
		// Only time loops inside Polybench kernel functions

		if(!result["function"].name.startsWith("kernel_")) {
			continue;
		}
		

		println(result["loop"].nestedLevel);
		println(result["loop"].iterations);

		loops.push(result["loop"]);
	}

	Parallelize.forLoops(loops);

	var pragmas = Parallelize.getForLoopsPragmas(loops);
	var astIds = Object.keys(pragmas["parallelLoops"]);

	var parLoops = [];
	for(var loop of loops) {
		if(astIds.includes(loop.astId)) {
			parLoops.push(loop);
		}
	}

	return parLoops;
}

function groupParLoops($parLoopsLvl0, $parLoopsRest) {
	var $loopGroups = [];
	var processedIds = [];
	var parLoopsRestIds = [];

	for(var $loop of $parLoopsRest) {
		parLoopsRestIds.push($loop.id);
	}
	
	for(var $loop of $parLoopsLvl0) {
		var currentGroup = [];
		currentGroup.push([$loop]);
		
		var $loopDescendants = $loop.descendants("loop");
		for(var $descendant of $loopDescendants) {
			if(parLoopsRestIds.includes($descendant.id)) {
				println("encontrou descendente nos outros loops");
				processedIds.push($descendant.id);
				var toAdd = [];
				for(var loops of currentGroup) {
					var newLoops = Array.from(loops);
					newLoops.push($descendant);
					toAdd.push(newLoops);
				}

				for(var elem of toAdd) {
					currentGroup.push(elem);
				}

				currentGroup.push([$descendant]);
			}
		}

		for(var elem of currentGroup) {
			$loopGroups.push(elem);
		}
		
	}

	for(var $loop of $parLoopsRest) {
		if(!processedIds.includes($loop.id))
			$loopGroups.push([$loop]);
	}

	println("$loopGroups.length: " + $loopGroups.length);
	println("$loopGroups data:\n");
	for(var index = 0; index < $loopGroups.length; index++) {
		for(var innerIndex = 0; innerIndex < $loopGroups[index].length; innerIndex++) {
			//var msg = "  [" + index + "]" + "[" + innerIndex + "] = " + $loopGroups[index][innerIndex].id;
			var msg = "  [" + index + "]" + "[" + innerIndex + "] = " + $loopGroups[index][innerIndex].line;
			println(msg);
		}
	}

	return $loopGroups;
}

function buildAndRun(benchmark, compoundId, nRuns, isPar) {
	var subFolder = "";

	var compoundIdStr = "";
	
	if(isPar) {
		compoundIdStr = String(compoundId);
		compoundIdStr = Strings.replacer(compoundIdStr, / /g, "_");
		subFolder = "/par/" + compoundIdStr;
	}
	else
		subFolder = "/seq";
	
	var folder = Io.mkdir(benchmark.outputFolder + subFolder);
	var buildFolder = Io.mkdir(benchmark.outputFolder + subFolder + "/build");
	Clava.writeCode(folder);

	var cmaker = new CMaker(benchmark.name);

	cmaker.addCurrentAst();
	cmaker.addLibs("m");
	cmaker.addFlags("-O3");	
	if(isPar)
		cmaker.addFlags("-fopenmp");

	var exe = cmaker.build(folder, buildFolder);

	var executors = [];
	var i;
	
	for(i = 0; i < nRuns; i++) {
		var executor = new ProcessExecutor();	
		//executor.setTimeout(1);
		executor.setPrintToConsole(false);
		var exeOutput = executor.execute(exe.getAbsolutePath());
		//println("output from executor: " + executor.getConsoleOutput());
		executors.push(executor);
	}
	

	return executors;
}

/*
	output
		a =10, b = "string";
	end
*/
	