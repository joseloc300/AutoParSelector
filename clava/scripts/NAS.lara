import clava.autopar.Parallelize;
import clava.autopar.ParallelizeLoop;
import lara.Io;
import lara.util.LocalFolder;
import clava.ClavaJoinPoints;
import lara.cmake.CMaker;
import weaver.util.WeaverDataStore;
import lara.code.Timer;
import lara.metrics.ExecutionTimeMetric;
import weaver.Query;
import lara.Strings;

import CustomExecutionTimeMetric;
import CustomParallelize;
import Utils;

aspectdef NAS
	input
		sourceFolder,
		benchmarkFolders,
		now,
		readCache,
		calculateCaches
	end

	var benchGroupName = "NAS";
	var start_time = performance.now();
	var nRuns = 3;
	var loopGroupSizeLimit = 1;
	var functionFilters = [];
	var problemSizeFlags = ["-DCLASS_S", /*"-DCLASS_W", "-DCLASS_A", "-DCLASS_B", "-DCLASS_C", "-DCLASS_D", "-DCLASS_E"*/];

	var NASResults = createBenchGroupResultsObj(nRuns, loopGroupSizeLimit);

	var allFolders = ["BT", "CG", "EP", "FT", "IS", "LU", "MG", "SP", "UA"];
	var foldersToGetExpectedC = ["BT", "EP", "FT", "IS", "LU", "MG"];
	var excludedFiles = ["expected_output.c"];
	var excludedFolders = ["test"];
	var benchmarks = getSubFolders(sourceFolder, benchmarkFolders, allFolders, excludedFiles, excludedFolders);

	NASResults["totalBenchmarks"] = benchmarks.length;
	NASResults["totalBenchmarkVersions"] = benchmarks.length * problemSizeFlags.length;

	var autoParLoopItersFolder = Io.getAbsolutePath("extraIncludes/");
	var autoParLoopItersHPath = Io.getPath(autoParLoopItersFolder, "autopar_loop_iters.h");
	var autoParLoopItersCPath = Io.getPath(autoParLoopItersFolder, "autopar_loop_iters.c");

	var xtraFiles = [];
	var xtraIncludeFolders = [];

	println("Number of benchmarks found: " + benchmarks.length);
	println("Processing benchmarks");
	for (var benchmark of benchmarks) {
		println("Processing: " + benchmark.folder);
		println("-new bench stack size = " + Clava.getStackSize());

		for(var problemSizeFlag of problemSizeFlags) {
			println("Current problem size flag = " + problemSizeFlag);
			println("--new problem size stack size = " + Clava.getStackSize());
		
			Clava.pushAst();
			var flags = [problemSizeFlag];
			if(problemSizeFlag == "-DCLASS_W") {
				flags = [];
			}

			var parLoops;
			var parLoopGroups;
			var benchmarkResults;
			var loopIterInfo;
			
			if(!readCache && foldersToGetExpectedC.includes(benchmark.name)) {
				//println("a");
				parLoops = getParLoopsFromPrevOutput(benchmark, xtraFiles, xtraIncludeFolders, flags);
				//println("b");
			}

			//println("c");
			rebuildCodeAst(benchmark, xtraFiles, xtraIncludeFolders, flags);
			//println("d");
			
			if(readCache) {
				parLoops = getObjFromCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "parLoops");
				if(Object.keys(parLoops).length == 0) {
					Clava.popAst();
					continue;
				}
				loopIterInfo = getObjFromCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "loopIterInfo");
				parLoopGroups = getObjFromCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "parLoopGroups");
				benchmarkResults = getObjFromCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "benchmarkResults");
			}
			else {
				//println("e");
				if(!foldersToGetExpectedC.includes(benchmark.name)) {
					//println("f");
					Clava.pushAst();
					parLoops = getParLoops(functionFilters);
					Clava.popAst();
					//println("g");
				}

				//println("h");
				if(Object.keys(parLoops).length == 0) {
					//println("i");
					Clava.popAst();
					writeObjToCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "parLoops", parLoops);
					//println("j");
					continue;
				}
				//println("k");
				benchmarkResults = createBenchResultsObj(benchmark, problemSizeFlag);
				//println("l");
				
				Clava.pushAst();
				var newExtraIncludeFolders = Array.from(xtraIncludeFolders);
				newExtraIncludeFolders.push(autoParLoopItersFolder);
				var newExtraFiles = Array.from(xtraFiles);
				newExtraFiles.push(autoParLoopItersHPath, autoParLoopItersCPath);

				rebuildCodeAst(benchmark, newExtraFiles, newExtraIncludeFolders, flags);
				loopIterInfo = countLoopIterations(benchmark, parLoops, problemSizeFlag, loopGroupSizeLimit);
				Clava.popAst();
				//println("m");

				parLoopGroups = getParLoopGroups(parLoops, loopGroupSizeLimit);
				//println("n");
				getLoopInfo(parLoops, loopIterInfo);
				//println("o");
				addLoopInfo(parLoops, benchmarkResults);
				//println("p");
				writeObjToCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "parLoops", parLoops);
				writeObjToCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "loopIterInfo", loopIterInfo);
				writeObjToCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "parLoopGroups", parLoopGroups);
				writeObjToCache(benchmark, benchGroupName, problemSizeFlag, loopGroupSizeLimit, "benchmarkResults", benchmarkResults);
				//println("q");

				//Clava.popAst();
			}

			//if only calculating caches skip timing the benchmarks
			if(calculateCaches) {
				Clava.popAst();
				continue;
			}
			
			NASResults["totalParLoops"] += Object.keys(parLoops).length;
			NASResults["totalVersions"] += parLoopGroups.length;
			NASResults["totalRuns"] += parLoopGroups.length * nRuns;
			
			var version = 0;
			for (var loopGroup of parLoopGroups) {
				println("---new loopGroup stack size = " + Clava.getStackSize());
			
				Clava.pushAst();
	
				addPragmas(loopGroup, parLoops);
	
				var measuresPar = addTimerPar(loopGroup, parLoops);
				var executorsPar = buildAndRun(benchmark, version, loopGroupSizeLimit, nRuns, true, problemSizeFlag);
				addResults(benchmarkResults, measuresPar, executorsPar, version, loopGroup, parLoops);
				version++;
				Clava.popAst();
			}
			
			var parLoopIds = Object.keys(parLoops);
	
			var measuresSeq = addTimerSeq(parLoopIds, parLoops);
			var executorsSeq = buildAndRun(benchmark, version, loopGroupSizeLimit, nRuns, false, problemSizeFlag);
			
			version = -1;
			addResults(benchmarkResults, measuresSeq, executorsSeq, version, loopGroup, parLoops);
			Clava.popAst();
			
			NASResults["benchmarks"].push(benchmarkResults);
			Io.writeJson(benchmark.outputFolder + problemSizeFlag + "/results.json", benchmarkResults);
		}
	}
	var end_time = performance.now();
	NASResults["totalExecutionTimeInSec"] = (end_time - start_time) / 1000;
	
	Io.writeJson("./results/" + benchGroupName + "_" + now.toISOString() + ".json", NASResults);
	println("Finished processing " + benchGroupName);

end
