import clava.autopar.Parallelize;
import clava.autopar.ParallelizeLoop;
import lara.Io;
import lara.util.LocalFolder;
import clava.ClavaJoinPoints;
import lara.cmake.CMaker;
import weaver.util.WeaverDataStore;
import lara.code.Timer;
import lara.metrics.ExecutionTimeMetric;
import weaver.Query;
import lara.Strings;

import CustomExecutionTimeMetric;
import CustomParallelize;
import Utils;

aspectdef NAS
	input
		sourceFolder,
		benchmarkFolders,
		now,
		readCache
	end

	var start_time = performance.now();
	var nRuns = 3;
	var functionFilters = [];

	var NASResults = {};
	NASResults["runsPerVersion"] = nRuns;
	NASResults["totalRuns"] = 0;
	NASResults["totalVersions"] = 0;
	NASResults["totalParLoops"] = 0;
	NASResults["totalExecutionTimeInSec"] = 0;
	NASResults["totalBenchmarks"] = 0;
	NASResults["benchmarks"] = [];

	var allFolders = ["BT", "CG", "EP", "FT", "IS", "LU", "MG", "SP", "UA"];
	var excludedFiles = ["expected_output.c"];
	var excludedFolders = [];
	var benchmarks = getSubFolders(sourceFolder, benchmarkFolders, allFolders, excludedFiles, excludedFolders);

	NASResults["totalBenchmarks"] = benchmarks.length;

	println("Number of benchmarks found: " + benchmarks.length);
	println("Processing benchmarks");
	for (var benchmark of benchmarks) {
		println("Processing: " + benchmark.folder);

		Clava.pushAst();
		var xtraCs = [];
		var xtraIncludeFolders = [];
		rebuildCodeAst(benchmark, xtraCs, xtraIncludeFolders);
		Clava.pushAst();

		var benchmarkResults = {};
		benchmarkResults["benchmark"] = benchmark.folder;
		
		benchmarkResults["par"] = {};
		benchmarkResults["par"]["nVersions"] = 0;
		benchmarkResults["par"]["versions"] = [];
		benchmarkResults["seq"] = [];

		var loopToIndex = {};
		var mainLoops = [];

		var parLoops = getParLoops(functionFilters);
		NASResults["totalParLoops"] += Object.keys(parLoops).length;

		var loopIterations = countLoopIterations(parLoops);
		
		var parLoopGroups = getParLoopGroups(parLoops, mainLoops);
		addLoopInfo(parLoops, benchmarkResults, loopToIndex, mainLoops);
		Clava.popAst();

		NASResults["totalVersions"] += parLoopGroups.length;
		NASResults["totalRuns"] += parLoopGroups.length * nRuns;
		var version = 0;
		for (var loopGroup of parLoopGroups) {
			Clava.pushAst();

			CustomParallelize.forLoops(loopGroup);

			var measuresPar = addTimerPar(loopGroup, loopToIndex, mainLoops);
			var executorsPar = buildAndRun(benchmark, version, nRuns, true);
			var loopIndexes = getLoopIndexes(loopGroup, loopToIndex);
			var mainLoopIndexes = getLoopIndexes(mainLoops, loopToIndex);
			addResults(benchmarkResults, measuresPar, executorsPar, true, loopIndexes, version, mainLoopIndexes);
			version++;
			Clava.popAst();
		}
		
		var parLoopIds = Object.keys(parLoops);

		var measuresSeq = addTimerSeq(parLoopIds, loopToIndex);
		var executorsSeq = buildAndRun(benchmark, version, nRuns, false);	
		addResults(benchmarkResults, measuresSeq, executorsSeq, false, null, null, null);
		Clava.popAst();
		
		NASResults["benchmarks"].push(benchmarkResults);
		Io.writeJson(benchmark.outputFolder + "/results.json", benchmarkResults);
	}
	var end_time = performance.now();
	NASResults["totalExecutionTimeInSec"] = (end_time - start_time) / 1000;
	
	Io.writeJson("./results/nas_" + now.toISOString() + ".json", NASResults);

end
