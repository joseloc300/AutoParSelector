import clava.autopar.Parallelize;
import lara.Io;
import lara.util.LocalFolder;
import clava.ClavaJoinPoints;
import lara.cmake.CMaker;
import weaver.util.WeaverDataStore;
import lara.code.Timer;
import lara.metrics.ExecutionTimeMetric;
import weaver.Query;
import lara.Strings;

function getLoopIndexes(loopGroup, parLoops) {
	var indexes = [];
	for(var loopId of loopGroup) {
		indexes.push(parLoops[loopId]["index"]);
	}

	return indexes;
}

function countLoopIterations(parLoops, params, loopItersFiles) {
	Clava.pushAst();

	var newExtraIncludeFolders = Array.from(params["xtraIncludeFolders"]);
	newExtraIncludeFolders.push(loopItersFiles["autoParLoopItersFolder"]);
	var newExtraFiles = Array.from(params["xtraFiles"]);
	newExtraFiles.push(loopItersFiles["autoParLoopItersHPath"], loopItersFiles["autoParLoopItersCPath"]);

	rebuildCodeAst(params, newExtraFiles, newExtraIncludeFolders, false);

	var loopIterInfo = {};
	var functionFilters = ["autopar_init_array", "autopar_array_exit_function"];
	var $allLoops = getLoopsFiltered(functionFilters, false);
	
	//filter non-"for" loops
	for(var i = 0; i < $allLoops.length; i++) {
		var $loop = $allLoops[i];
		if($loop.kind != "for") {
			$allLoops.splice(i, 1);
			println("removed elem");
		}
	}

	var allLoopIds = Object.keys($allLoops);
	var nLoops = allLoopIds.length;

	var $program = Clava.getProgram();
	var $files = $program.files;
	var $chosenFile;
	
	for(var $file of $files) {
		if($file.name.endsWith(".c")) {
			$file.addInclude("autopar_loop_iters.h");
		}
		if($file.hasMain) {
			$chosenFile = $file;
		}
	}

	var $exitFunction;
	for(var $function of Query.search('function')) {
		if($function.name == "autopar_array_exit_function") {
			$exitFunction = $function;
			println("found it");
			break;
		}
		println("iter");
	}
	
	$program.atexit($exitFunction);

	var initArrayCallCode = "autopar_init_array(" + nLoops + ");";
	var $mainFunctionBody = $program.main.body;
	$mainFunctionBody.insertBegin(initArrayCallCode);

	var loopIndexToId = [];
	var index = 0;
	for(var $loop of $allLoops) {
		
		loopIndexToId.push($loop.id);
		loopIterInfo[$loop.id] = createLoopIterationObj();

		//update total calls
		var loopCode = "autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].total_calls += 1;\n";

		//update sum iters
		loopCode += "autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].sum_iters += " + $loop.iterationsExpr.code + ";\n";
		
		//update sum iters squared
		loopCode += "autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].sum_iters_squared += pow(" + 
			$loop.iterationsExpr.code + ", 2.0);\n";
	
		//update max iters
		loopCode += "if(autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].max_iters < " + 
			$loop.iterationsExpr.code + ") " + "autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].max_iters = " + 
			$loop.iterationsExpr.code + ";\n";

		//update min iters
		loopCode += "if(autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].min_iters > " + 
			$loop.iterationsExpr.code + ") " + "autopar_loop_iters_array[omp_get_thread_num() * " + nLoops + " + " + index + "].min_iters = " + 
			$loop.iterationsExpr.code + ";\n";

		
		$loop.insertBefore(loopCode);
		if($loop.nestedLevel == 0 && Object.keys(parLoops).contains($loop.id)) {
			$loop.insertBefore(parLoops[$loop.id]["ompPragma"]);
		}
		
		index++;
	}
	
	var executorPar = buildAndRun(params, "iterCounter", 1, true)[0];
	var consoleOutput = executorPar.getConsoleOutput();

	println(consoleOutput);

	exit(0);

	getLoopIterationStats(loopIndexToId, consoleOutput, parLoops, loopIterInfo, nLoops);

	Clava.popAst();
	return loopIterInfo;	
}

function getLoopIterationStats(loopIndexToId, consoleOutput, parLoops, loopIterInfo, nLoops) {
	//constants
	var MAX_ITERS_INDEX = 0;
	var MIN_ITERS_INDEX = 1;
	var SUM_ITERS_INDEX = 2;
	var SUM_ITERS_SQUARED_INDEX = 3;
	var TOTAL_CALLS_INDEX = 4;


	var lines = consoleOutput.split("\n");
	for(var line of lines) {
		if(!line.startsWith("autopar_loop_iters"))
			continue;

		//get array index
		var openSquareBracketIndex = line.indexOf("["); 
		var closeSquareBracketIndex = line.indexOf("]");
		var arrayIndex = parseInt(line.slice(openSquareBracketIndex + 1, closeSquareBracketIndex)) % nLoops;

		//get values
		var openCurlyBracketIndex = line.indexOf("{"); 
		var closeCurlyBracketIndex = line.indexOf("}");
		var values = (line.slice(openCurlyBracketIndex + 1, closeCurlyBracketIndex)).split(",");

		//parse values to int
		for(var i = 0; i < values.length; i++) {
			values[i] = Number(values[i]);
		}

		//skip if total calls == 0
		if(values[TOTAL_CALLS_INDEX] == 0)
			continue;

		//update loopIterInfo
		var loopId = loopIndexToId[arrayIndex];
		if(values[MAX_ITERS_INDEX] > loopIterInfo[loopId]["maxIterations"])
			loopIterInfo[loopId]["maxIterations"] = values[MAX_ITERS_INDEX];		
		if(values[MIN_ITERS_INDEX] < loopIterInfo[loopId]["minIterations"])
			loopIterInfo[loopId]["minIterations"] = values[MIN_ITERS_INDEX];		
		loopIterInfo[loopId]["avgIterations"] += values[SUM_ITERS_INDEX];	
		loopIterInfo[loopId]["stdDevIterations"] += values[SUM_ITERS_SQUARED_INDEX];	
		loopIterInfo[loopId]["totalCalls"] += values[TOTAL_CALLS_INDEX];
		
	}

	//finish avg and stddev calculations
	var loopIterInfoIds = Object.keys(loopIterInfo);
	for(var loopId of loopIterInfoIds) {
		if(loopIterInfo[loopId]["avgIterations"] == 0)
			continue;
		
		loopIterInfo[loopId]["avgIterations"] /= loopIterInfo[loopId]["totalCalls"];
		loopIterInfo[loopId]["stdDevIterations"] /= loopIterInfo[loopId]["totalCalls"];
		loopIterInfo[loopId]["stdDevIterations"] -= Math.pow(loopIterInfo[loopId]["avgIterations"], 2);
		loopIterInfo[loopId]["stdDevIterations"] = Math.sqrt(loopIterInfo[loopId]["stdDevIterations"]);
	}

	//update loop without calls
	for(var loopId of loopIterInfoIds) {
		if(loopIterInfo[loopId]["avgIterations"] != 0)
			continue;
		
		loopIterInfo[loopId]["maxIterations"] = 0;
		loopIterInfo[loopId]["minIterations"] = 0;
		loopIterInfo[loopId]["avgIterations"] = 0;
		loopIterInfo[loopId]["stdDevIterations"] = 0;
	}

	updateParLoopItersInfo(parLoops, loopIterInfo);
}

function updateParLoopItersInfo(parLoops, loopIterInfo) {
	var parLoopIds = Object.keys(parLoops);

	for(var loopId of parLoopIds) {
		parLoops[loopId]["maxIterations"] = loopIterInfo[loopId]["maxIterations"];
		parLoops[loopId]["minIterations"] = loopIterInfo[loopId]["minIterations"];
		parLoops[loopId]["avgIterations"] = loopIterInfo[loopId]["avgIterations"];
		parLoops[loopId]["stdDevIterations"] = loopIterInfo[loopId]["stdDevIterations"];
		parLoops[loopId]["hasIterationVariation"] = parLoops[loopId]["maxIterations"] != parLoops[loopId]["minIterations"];
		parLoops[loopId]["timesLoopIsCalled"] = loopIterInfo[loopId]["totalCalls"];

		var parentLoopId = parLoops[loopId]["parentLoopId"];
		if(parentLoopId == "NULL")
			continue;
		
		parLoops[loopId]["maxParentIterations"] = loopIterInfo[parentLoopId]["maxIterations"];
		parLoops[loopId]["minParentIterations"] = loopIterInfo[parentLoopId]["minIterations"];
		parLoops[loopId]["avgParentIterations"] = loopIterInfo[parentLoopId]["avgIterations"];
		parLoops[loopId]["stdDevParentIterations"] = loopIterInfo[parentLoopId]["stdDevIterations"];	
		parLoops[loopId]["hasParentIterationVariation"] = parLoops[loopId]["maxParentIterations"] != parLoops[loopId]["minParentIterations"];;
	}
}

function createLoopIterationObj() {
	var loopIterationObj = {};
	
	loopIterationObj["maxIterations"] = 0;
	loopIterationObj["minIterations"] = Number.MAX_SAFE_INTEGER;
	loopIterationObj["avgIterations"] = 0;
	loopIterationObj["stdDevIterations"] = 0;
	loopIterationObj["totalCalls"] = 0;

	return loopIterationObj;
}

function getLoopInfo(parLoops, loopIterInfo) {
	var parLoopIds = Object.keys(parLoops);
	var $loopJps = getLoopsFromIds(parLoopIds);

	var index = 0;
	for(var loopId of parLoopIds) {
		var $loop = $loopJps[loopId];
		var loopInstructionInfo = getInstructionInfo($loop, loopIterInfo);
		
		parLoops[loopId]["origLine"] = $loop.line;
		parLoops[loopId]["nestedLevel"] = $loop.nestedLevel;
		parLoops[loopId]["isInnermost"] = $loop.isInnermost;
		parLoops[loopId]["isOutermost"] = $loop.isOutermost;
		parLoops[loopId]["rank"] = Array.from($loop.rank);
		parLoops[loopId]["index"] = index;
		
		parLoops[loopId]["instructionInfo"] = loopInstructionInfo;
		
		index++;
	}
}

function addLoopInfo(parLoops, benchmarkResults) {
	benchmarkResults["nLoops"] = parLoops.length;
	benchmarkResults["loops"] = {};
	var parLoopIds = Object.keys(parLoops);
	
	for(var loopId of parLoopIds) {
		var index = parLoops[loopId]["index"];	
		benchmarkResults["loops"][index] = parLoops[loopId];
	}
}

function createInstructionInfoObj() {
	var instructionInfo = {};
	
	//joinpoints descendant from the loop
	instructionInfo["joinpoints"] = {};
	instructionInfo["joinpoints"]["arrayAccess"] = 0;
	instructionInfo["joinpoints"]["binaryOp"] = 0;
	instructionInfo["joinpoints"]["call"] = 0;
	instructionInfo["joinpoints"]["cast"] = 0;
	instructionInfo["joinpoints"]["decl"] = 0;
	instructionInfo["joinpoints"]["declarator"] = 0;
	instructionInfo["joinpoints"]["deleteExpr"] = 0;
	instructionInfo["joinpoints"]["enumDecl"] = 0;
	instructionInfo["joinpoints"]["enumeratorDecl"] = 0;
	instructionInfo["joinpoints"]["expression"] = 0;
	instructionInfo["joinpoints"]["if"] = 0;
	instructionInfo["joinpoints"]["loop"] = 0;
	instructionInfo["joinpoints"]["memberAccess"] = 0;
	instructionInfo["joinpoints"]["memberCall"] = 0;
	instructionInfo["joinpoints"]["namedDecl"] = 0;
	instructionInfo["joinpoints"]["newExpr"] = 0;
	instructionInfo["joinpoints"]["op"] = 0;
	instructionInfo["joinpoints"]["returnStmt"] = 0;
	instructionInfo["joinpoints"]["statement"] = 0;
	instructionInfo["joinpoints"]["typeDefDecl"] = 0;
	instructionInfo["joinpoints"]["typeDefNameDecl"] = 0;
	instructionInfo["joinpoints"]["unaryExprOrType"] = 0;
	instructionInfo["joinpoints"]["unaryOp"] = 0;
	instructionInfo["joinpoints"]["vardecl"] = 0;
	instructionInfo["joinpoints"]["varref"] = 0;
	instructionInfo["joinpointsTotal"] = 0;

	//joinpoints descendant from the loop taking into account inner loops and function calls
	instructionInfo["recursiveJoinpoints"] = {};
	instructionInfo["recursiveJoinpoints"]["arrayAccess"] = 0;
	instructionInfo["recursiveJoinpoints"]["binaryOp"] = 0;
	instructionInfo["recursiveJoinpoints"]["call"] = 0;
	instructionInfo["recursiveJoinpoints"]["cast"] = 0;
	instructionInfo["recursiveJoinpoints"]["decl"] = 0;
	instructionInfo["recursiveJoinpoints"]["declarator"] = 0;
	instructionInfo["recursiveJoinpoints"]["deleteExpr"] = 0;
	instructionInfo["recursiveJoinpoints"]["enumDecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["enumeratorDecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["expression"] = 0;
	instructionInfo["recursiveJoinpoints"]["if"] = 0;
	instructionInfo["recursiveJoinpoints"]["loop"] = 0;
	instructionInfo["recursiveJoinpoints"]["memberAccess"] = 0;
	instructionInfo["recursiveJoinpoints"]["memberCall"] = 0;
	instructionInfo["recursiveJoinpoints"]["namedDecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["newExpr"] = 0;
	instructionInfo["recursiveJoinpoints"]["op"] = 0;
	instructionInfo["recursiveJoinpoints"]["returnStmt"] = 0;
	instructionInfo["recursiveJoinpoints"]["statement"] = 0;
	instructionInfo["recursiveJoinpoints"]["typeDefDecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["typeDefNameDecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["unaryExprOrType"] = 0;
	instructionInfo["recursiveJoinpoints"]["unaryOp"] = 0;
	instructionInfo["recursiveJoinpoints"]["vardecl"] = 0;
	instructionInfo["recursiveJoinpoints"]["varref"] = 0;
	instructionInfo["recursiveJoinpointsTotal"] = 0;

	//derived info from recursive joinpoints info
	//arrayAccess
	instructionInfo["arrayAccessRead"] = 0;
	instructionInfo["arrayAccessWrite"] = 0;
	instructionInfo["arrayAccessReadWrite"] = 0;

	//binaryOp
	instructionInfo["binaryOpArithmetic"] = 0;
	instructionInfo["binaryOpLogic"] = 0;
	instructionInfo["binaryOpComparison"] = 0;
	instructionInfo["binaryOpAssignment"] = 0;
	instructionInfo["binaryOpBitwise"] = 0;
	instructionInfo["binaryOpBitwiseAssignment"] = 0;
	instructionInfo["binaryOpArithmeticAssignment"] = 0;

	//unaryOp
	instructionInfo["unaryOpArithmetic"] = 0;
	instructionInfo["unaryOpLogic"] = 0;
	instructionInfo["unaryOpComparison"] = 0;
	instructionInfo["unaryOpAssignment"] = 0;
	instructionInfo["unaryOpBitwise"] = 0;
	instructionInfo["unaryOpBitwiseAssignment"] = 0;
	instructionInfo["unaryOpArithmeticAssignment"] = 0;

	//binaryOp + unaryOp
	instructionInfo["totalArithmetic"] = 0;
	instructionInfo["totalLogic"] = 0;
	instructionInfo["totalComparison"] = 0;
	instructionInfo["totalAssignment"] = 0;
	instructionInfo["totalBitwise"] = 0;
	instructionInfo["totalBitwiseAssignment"] = 0;
	instructionInfo["totalArithmeticAssignment"] = 0;

	//call + memberCall
	instructionInfo["callAvgNumberArgs"] = 0;
	instructionInfo["callExternal"] = 0;
	instructionInfo["callLevel0"] = 0;
	instructionInfo["callNested"] = 0;
	instructionInfo["callFunction"] = 0;
	instructionInfo["callMethod"] = 0;
	instructionInfo["callInnerJps"] = 0;
	instructionInfo["callRecursive"] = 0;

	//cast
	instructionInfo["castImplicit"] = 0;
	instructionInfo["castExplicit"] = 0;

	//loop
	instructionInfo["loopFor"] = 0;
	instructionInfo["loopWhile"] = 0;
	instructionInfo["loopDoWhile"] = 0;
	instructionInfo["loopForEach"] = 0;

	//memberAccess
	instructionInfo["memberAccessRead"] = 0;
	instructionInfo["memberAccessWrite"] = 0;
	instructionInfo["memberAccessReadWrite"] = 0;

	//vardecl
	instructionInfo["vardeclHasInit"] = 0;
	instructionInfo["vardeclGlobal"] = 0;
	instructionInfo["vardeclParam"] = 0;

	//varref
	instructionInfo["varrefRead"] = 0;
	instructionInfo["varrefWrite"] = 0;
	instructionInfo["varrefReadWrite"] = 0;	

	return instructionInfo;
}

function getInstructionInfo($loop, loopIterInfo) {
	var instructionInfo = createInstructionInfoObj();
	instructionAnalyser($loop, $loop, instructionInfo, loopIterInfo);
	callAnalyser($loop, instructionInfo, loopIterInfo);

	return instructionInfo;
}

function getJPDescendants($targetJp, $mainLoop, instructionInfo, loopIterInfo) {
	var jpTypes = Object.keys(instructionInfo["joinpoints"]);
	var $descendants = {};
	$descendants["total"] = 0;

	for(var jpType of jpTypes) {
		$descendants[jpType] = $targetJp.descendants(jpType);

		if($targetJp.instanceOf("loop") && $targetJp.id == $mainLoop.id) {
			instructionInfo["joinpoints"][jpType] += $descendants[jpType].length;
			instructionInfo["joinpointsTotal"] += $descendants[jpType].length;
		}

		//go $jp by $jp and calculate avg times they will be run per main loop iteration
		for(var $descendant of $descendants[jpType]) {
			var iterMultiplier = getJpMultiplier($descendant, $mainLoop, loopIterInfo);
			instructionInfo["recursiveJoinpoints"][jpType] += iterMultiplier;
			instructionInfo["recursiveJoinpointsTotal"] += iterMultiplier;
			$descendants["total"] += iterMultiplier;
		}
		
	}

	return $descendants;
}

function getJpMultiplier($jp, $mainLoop, loopIterInfo) {
	var iterMultiplier = 1;
	var $currentLoop = $jp.ancestor("loop");
	while(typeof $currentLoop !== "undefined" && $currentLoop.id != $mainLoop.id) {
		iterMultiplier *= loopIterInfo[$currentLoop.id]["avgIterations"];
		$currentLoop = $currentLoop.ancestor("loop");
	}
	return iterMultiplier;
}

function callAnalyser($mainLoop, instructionInfo, loopIterInfo) {
	var $calls = $mainLoop.descendants("call");

	for(var $call of $calls) {
		instructionInfo["callLevel0"] += 1;
		instructionInfo["callAvgNumberArgs"] += $call.numArgs;
		
		if($call.instanceOf("memberCall"))
			instructionInfo["callMethod"] += 1;
		else
			instructionInfo["callFunction"] += 1;
	
		var $function = $call.function;
		var functionId = $function.id;
		var $functionDefinition = $function.definitionJp;

		if(typeof $functionDefinition === "undefined") {
			instructionInfo["callExternal"] += 1;
			continue;
		}

		var callStack = [];
		callAnalyserAux($functionDefinition, $mainLoop, functionId, callStack, instructionInfo, loopIterInfo);	
	}
	if(instructionInfo["joinpoints"]["call"] > 0)
		instructionInfo["callAvgNumberArgs"] /= instructionInfo["joinpoints"]["call"];
}

function callAnalyserAux($functionDefinition, $mainLoop, functionId, callStack, instructionInfo, loopIterInfo) {
	if(callStack.contains(functionId)) {
		instructionInfo["callRecursive"] += 1;
		return;
	}

	var nFoundJps = instructionAnalyser($functionDefinition, $mainLoop, instructionInfo, loopIterInfo);
	instructionInfo["callInnerJps"] += nFoundJps;

	var $calls = $functionDefinition.descendants("call");

	for(var $call of $calls) {
		instructionInfo["callNested"] += 1;

		if($call.instanceOf("memberCall"))
			instructionInfo["callMethod"] += 1;
		else
			instructionInfo["callFunction"] += 1;
	
		var $function = $call.function;
		var functionId = $function.id;
		var $functionDefinition = $function.definitionJp;

		if(typeof $functionDefinition === "undefined") {
			instructionInfo["callExternal"] += 1;
			continue;
		}
		
		var callStack = Array.from(callStack);
		callStack.push(functionId);

		callAnalyserAux($functionDefinition, $mainLoop, functionId, callStack, instructionInfo, loopIterInfo);
	}

	return;
}

function instructionAnalyser($jp, $mainLoop, instructionInfo, loopIterInfo) {
	var $descendants = getJPDescendants($jp, $mainLoop, instructionInfo, loopIterInfo);
	
	arrayAccessesAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	unaryBinaryOpsAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	castAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	expressionAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	loopAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	memberAccessAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	vardeclAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);
	varrefAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo);

	return $descendants["total"];
}

function arrayAccessesAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $arrayAccess of $descendants["arrayAccess"]) {
		var iterMultiplier = getJpMultiplier($arrayAccess, $mainLoop, loopIterInfo);
		var use = $arrayAccess.use;
		switch(use) {
			case "read":
				instructionInfo["arrayAccessRead"] += iterMultiplier;
				break;
			case "write":
				instructionInfo["arrayAccessWrite"] += iterMultiplier;
				break;
			case "readwrite":
				instructionInfo["arrayAccessReadWrite"] += iterMultiplier;
				break;
		}
	}
}

function unaryBinaryOpsAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	var arithmeticOperators = ["+", "-", "*", "/", "%", "++", "--"];
	var logicOperators = ["||", "&&", "!"];
	var comparisonOperators = ["==", "!=", "<", "<=", ">", ">="];
	var assignmentOperators = ["="];
	var bitwiseOperators = ["&", "|", "^", "~", "<<", ">>"];
	var arithmeticAssignmentOperators = ["+=", "-=", "*=", "/=", "%="];
	var bitwiseAssignmentOperators = ["&=", "|=", "^=", ">>=", "<<="];

	for(var $binaryOp of $descendants["binaryOp"]) {
		var iterMultiplier = getJpMultiplier($binaryOp, $mainLoop, loopIterInfo);
		
		if(arithmeticOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpArithmetic"] += iterMultiplier;
			instructionInfo["totalArithmetic"] += iterMultiplier;
		}
		else if(logicOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpLogic"] += iterMultiplier;
			instructionInfo["totalLogic"] += iterMultiplier;
		}
		else if(comparisonOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpComparison"] += iterMultiplier;
			instructionInfo["totalComparison"] += iterMultiplier;
		}
		else if(assignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
		}
		else if(bitwiseOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpBitwise"] += iterMultiplier;
			instructionInfo["totalBitwise"] += iterMultiplier;
		}
		else if(bitwiseAssignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpBitwiseAssignment"] += iterMultiplier;
			instructionInfo["binaryOpBitwise"] += iterMultiplier;
			instructionInfo["binaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
			instructionInfo["totalBitwise"] += iterMultiplier;
			instructionInfo["totalBitwiseAssignment"] += iterMultiplier;
		}
		else if(arithmeticAssignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpArithmeticAssignment"] += iterMultiplier;
			instructionInfo["binaryOpArithmetic"] += iterMultiplier;
			instructionInfo["binaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
			instructionInfo["totalArithmetic"] += iterMultiplier;
			instructionInfo["totalArithmeticAssignment"] += iterMultiplier;
		}
		
	}

	for(var $unaryOp of $descendants["unaryOp"]) {
		var iterMultiplier = getJpMultiplier($unaryOp, $mainLoop, loopIterInfo);
	
		if(arithmeticOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpArithmetic"] += iterMultiplier;
			instructionInfo["totalArithmetic"] += iterMultiplier;
		}
		else if(logicOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpLogic"] += iterMultiplier;
			instructionInfo["totalLogic"] += iterMultiplier;
		}
		else if(comparisonOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpComparison"] += iterMultiplier;
			instructionInfo["totalComparison"] += iterMultiplier;
		}
		else if(assignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
		}
		else if(bitwiseOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpBitwise"] += iterMultiplier;
			instructionInfo["totalBitwise"] += iterMultiplier;
		}
		else if(bitwiseAssignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpBitwiseAssignment"] += iterMultiplier;
			instructionInfo["unaryOpBitwise"] += iterMultiplier;
			instructionInfo["unaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
			instructionInfo["totalBitwise"] += iterMultiplier;
			instructionInfo["totalBitwiseAssignment"] += iterMultiplier;
		}
		else if(arithmeticAssignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpArithmeticAssignment"] += iterMultiplier;
			instructionInfo["unaryOpArithmetic"] += iterMultiplier;
			instructionInfo["unaryOpAssignment"] += iterMultiplier;
			instructionInfo["totalAssignment"] += iterMultiplier;
			instructionInfo["totalArithmetic"] += iterMultiplier;
			instructionInfo["totalArithmeticAssignment"] += iterMultiplier;
		}
	}
}

function castAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $cast of $descendants["cast"]) {
		var iterMultiplier = getJpMultiplier($cast, $mainLoop, loopIterInfo);
		instructionInfo["castExplicit"] += iterMultiplier;
	}
}

function expressionAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $expression of $descendants["expression"]) {
		var iterMultiplier = getJpMultiplier($expression, $mainLoop, loopIterInfo);
		if(typeof $expression.implicitCast !== "undefined")
			instructionInfo["castImplicit"] += iterMultiplier;
	}
}

function loopAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $loop of $descendants["loop"]) {
		var iterMultiplier = getJpMultiplier($loop, $mainLoop, loopIterInfo);
		var kind = $loop.kind;
		switch(kind) {
			case "for":
				instructionInfo["loopFor"] += iterMultiplier;
				break;
			case "while":
				instructionInfo["loopWhile"] += iterMultiplier;
				break;
			case "dowhile":
				instructionInfo["loopDoWhile"] += iterMultiplier;
				break;
			case "foreach":
				instructionInfo["loopForEach"] += iterMultiplier;
				break;
		}
	}
}

function memberAccessAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $memberAccess of $descendants["memberAccess"]) {
		var iterMultiplier = getJpMultiplier($memberAccess, $mainLoop, loopIterInfo);
		var use = $memberAccess.use;
		switch(use) {
			case "read":
				instructionInfo["memberAccessRead"] += iterMultiplier;
				break;
			case "write":
				instructionInfo["memberAccessWrite"] += iterMultiplier;
				break;
			case "readwrite":
				instructionInfo["memberAccessReadWrite"] += iterMultiplier;
				break;
		}
	}
}

function vardeclAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $vardecl of $descendants["vardecl"]) {
		var iterMultiplier = getJpMultiplier($vardecl, $mainLoop, loopIterInfo);	
		if($vardecl.hasInit)
			instructionInfo["vardeclHasInit"] += iterMultiplier;
		if($vardecl.isGlobal)
			instructionInfo["vardeclGlobal"] += iterMultiplier;
		if($vardecl.isParam)
			instructionInfo["vardeclParam"] += iterMultiplier;
	}
}

function varrefAnalyzer($descendants, $mainLoop, instructionInfo, loopIterInfo) {
	for(var $varref of $descendants["varref"]) {
		var iterMultiplier = getJpMultiplier($varref, $mainLoop, loopIterInfo);
		var use = $varref.use;
		switch(use) {
			case "read":
				instructionInfo["varrefRead"] += iterMultiplier;
				break;
			case "write":
				instructionInfo["varrefWrite"] += iterMultiplier;
				break;
			case "readwrite":
				instructionInfo["varrefReadWrite"] += iterMultiplier;
				break;
		}
	}
}


function addResults(benchmarkResults, measures, executors, version, loopGroup, parLoops) {
	var MPREFIX_LENGTH = 8;
	var isPar = version >= 0;
	
	var loopIndexes = getLoopIndexes(loopGroup, parLoops);
	var mainLoopIds = getMainLoopIds(parLoops);
	var mainLoopIndexes = getLoopIndexes(mainLoopIds, parLoops);

	var name = "";
	var info = {};
	if (isPar) {
		name = "par";
		benchmarkResults["par"]["nVersions"] += 1;
		info["version"] = version;
		info["parLoops"] = Array.from(loopIndexes);
		info["mainLoop"] = 0;
		info["measures"] = [];
	}
	else
		name = "seq";

	for(var measure of measures) {
		var measureInfo = {};
		var loopIndex = measure._prefix.substring(MPREFIX_LENGTH);
		loopIndex = parseInt(loopIndex);
		measureInfo["loopIndex"] = parseInt(loopIndex);
		measureInfo["runs"] = [];
		var runId = 0;
		for(var executor of executors) {
			var res = measure.report(executor);
			var newRes = {};
			newRes.value = res.getValue();
			newRes.unit = res.getUnit();
			measureInfo["runs"].push(newRes);
			runId++;
		}

		if(isPar) {
			info["measures"].push(measureInfo);
			if(mainLoopIndexes.includes(loopIndex))
				info["mainLoop"] = loopIndex;
		}
		else {
			benchmarkResults["seq"].push(measureInfo);
		}
	}

	if(isPar) {
		benchmarkResults["par"]["versions"].push(info);
	}
	
}

function getSubFolders(params) {
	var sourceFolder = params["sourceFolder"];
	var benchmarkFolders = params["benchmarkFolders"];
	var allFolders = params["allFolders"];
	var excludedFiles = params["excludedFiles"];
	var excludedFolders = params["excludedFolders"];

	if (benchmarkFolders.length == 1 && benchmarkFolders[0] == "all")
		benchmarkFolders = allFolders;

	var benchmarks = [];
	var foldersChecked = [];

	for (var folder of benchmarkFolders) {
		var folderPath = sourceFolder + folder;
		
		if(!Io.isFolder(folderPath)) {
			println(folderPath + " is not a valid folder.");
			continue;
		}

		var folder = new LocalFolder(folderPath);
		var fileList = folder.getFileList();

		for (var file of fileList) {
			var fileString = file.toString();
			if(!fileString.endsWith(".c"))
				continue;

			var skipFile = false;
			for(var excludedFile of excludedFiles) {
				if(fileString.endsWith(excludedFile)) {
					skipFile = true;
					break;
				}
			}

			if(skipFile)
				continue;

			var benchmark = createBenchmarkObj(fileString);

			for(excludedFolder of excludedFolders) {
				if(benchmark.folder.endsWith(excludedFolder))
				skipFile = true;
			}

			if(skipFile)
				continue;
	
			
			if(foldersChecked.contains(benchmark.folder))
				continue;

			benchmarks.push(benchmark);
			foldersChecked.push(benchmark.folder);

		}
	}
	return benchmarks;
}

function createBenchmarkObj(fileString) {
	var benchmark = new Object();

	var lastSlash = fileString.lastIndexOf("/");
	var benchGroupNameIndex = fileString.indexOf("/sources/") + 9;
	benchmark.c = Io.getAbsolutePath(fileString);
	benchmark.folder = Io.getAbsolutePath(fileString.slice(0, lastSlash));
	benchmark.cacheFolder = Io.getAbsolutePath("./cache/" + fileString.slice(benchGroupNameIndex, lastSlash));
	benchmark.outputFolder = Io.getAbsolutePath("./outputs/" + fileString.slice(benchGroupNameIndex, lastSlash));

	var lastSlashFolder = benchmark.folder.lastIndexOf("/");
	benchmark.name = benchmark.folder.substring(lastSlashFolder + 1);

	return benchmark;
}

function rebuildCodeAst(params, xtraFiles, xtraIncludeFolders, readFromExpectedC) {
	var benchmark = params["dynamic"]["benchmark"];
	var preprocessorFlags = params["dynamic"]["preprocessorFlags"];

	var includeFolders = Array.from(xtraIncludeFolders);
	includeFolders.push(benchmark.folder);

	var dataStore = Clava.getData();
	dataStore.setUserIncludes(includeFolders);
	var flagString = concatFlags(preprocessorFlags);
	dataStore.setFlags(flagString);

	var files = Array.from(xtraFiles);
	files.push(benchmark.c);
	if(readFromExpectedC) {
		var expectedCPath = benchmark.folder + "/expected_output.c";
		files.push(expectedCPath);
	}
	
	for(var file of files) {
		var clavaJPFile = ClavaJoinPoints.file(file);
		Clava.addFile(clavaJPFile);
	}

	Clava.rebuild();
}

function addTimerSeq(mainLoopIds, parLoops) {

	var measures = [];

	for(var result of Query.search('function').search('loop').chain()) {
		if(!mainLoopIds.includes(result["loop"].id)) {
			continue;
		}

		var measurePrefix = "mprefix_" + parLoops[result["loop"].id]["index"].toString();
		var measure = new CustomExecutionTimeMetric(measurePrefix);
		measures.push(measure);
		
		measure.instrument(result["loop"]);
	}

	return measures;
}

function addTimerMainLoop(mainLoopId, mainLoopIndex) {
	var measure;
	for(var result of Query.search('function').search('loop').chain()) {
		if(result["loop"].id != mainLoopId) {
			continue;
		}

		var measurePrefix = "mprefix_" + mainLoopIndex;
		measure = new CustomExecutionTimeMetric(measurePrefix);	
		measure.instrument(result["loop"], undefined, true);
		break;
	}
	return measure;
}

function addTimerPar(loopGroup, parLoops) {
	var measures = [];
	var mainLoopIds = getMainLoopIds(parLoops);
	var foundMainLoop = false;

	
	for(var result of Query.search('pragma')) {
		if(result.name != "omp")
			continue;

		var $pragmaLoop = result.target;

		if(!loopGroup.includes($pragmaLoop.id))
			continue;

		if(!mainLoopIds.includes($pragmaLoop.id))
			continue;

		var foundMainLoop = true;

		var $pragmaLoop = result.target;
		var measurePrefix = "mprefix_" + parLoops[$pragmaLoop.id]["index"].toString();
		var measure = new CustomExecutionTimeMetric(measurePrefix);
		measures.push(measure);		
		measure.instrument(result, $pragmaLoop, true);	
	}

	if(!foundMainLoop) {
		var subMainLoopId = getSubMainLoopId(loopGroup, parLoops);
		var mainLoopMeasure = findAndTimeMainLoop(subMainLoopId, parLoops, mainLoopIds);
		measures.push(mainLoopMeasure);
	}

	return measures;
}

function findAndTimeMainLoop(subMainLoopId, parLoops, mainLoopIds) {
	var $subMainLoop = getLoopsFromIds([subMainLoopId])[subMainLoopId];
	var $mainLoopJps = getLoopsFromIds(mainLoopIds);
	var mainLoopMeasure;
	for(var mainLoopId of mainLoopIds) {
		var $mainLoop = $mainLoopJps[mainLoopId];
		if(checkRankDescendant($subMainLoop.rank, $mainLoop.rank)) {
			var mainLoopIndex = parLoops[$mainLoop.id]["index"].toString();
			mainLoopMeasure = addTimerMainLoop($mainLoop.id, mainLoopIndex);
			break;
		}
	}

	return mainLoopMeasure;
}

/**
checks if loop with the rank loopRank0 is descendant from the loop with the rank loopRank1
@param loopRank0 int[], rank from loop we intend to check
@param loopRank1 int[], rank from loop we intend to check against
@return boolean, true if loop with the rank loopRank0 is descendant from the loop with the rank loopRank1
**/
function checkRankDescendant(loopRank0, loopRank1) {
	if(loopRank0.length <= loopRank1.length)
		return false;
	
	for(var i = 0; i < loopRank1.length; i++) {
		if(loopRank1[i] != loopRank0[i])
			return false;
	}

	return true;
}

function getParLoopGroups(parLoops, loopGroupSizeLimit) {
	var loopGroups = [];
	var processedIds = [];
	var parLoopIds = Object.keys(parLoops);
	var $loopJps = getLoopsFromIds(parLoopIds);
	var currLvl = 0;

	while(processedIds.length < parLoopIds.length) {

		for(var loopId of parLoopIds) {
			var $loop = $loopJps[loopId];
		
			if($loop.nestedLevel != currLvl || processedIds.includes(loopId))
				continue;
		
			var currentGroup = [];
			currentGroup.push([loopId]);
			processedIds.push(loopId);
			parLoops[loopId]["isMainLoop"] = true;
			
			var $loopDescendants = $loop.descendants("loop");
			for(var $descendant of $loopDescendants) {
				if(!parLoopIds.includes($descendant.id)) {
					continue;
				}

				processedIds.push($descendant.id);
				var toAdd = [];
				for(var loops of currentGroup) {
					var newLoops = Array.from(loops);
					newLoops.push($descendant.id);
					toAdd.push(newLoops);
				}

				for(var elem of toAdd) {
					currentGroup.push(elem);
				}

				currentGroup.push([$descendant.id]);
			}
	
			for(var elem of currentGroup) {
				loopGroups.push(elem);
			}
			
		}

		currLvl += 1;
		
	}

	filterLoopGroups(loopGroups, loopGroupSizeLimit);

	return loopGroups;
}

function filterLoopGroups(loopGroups, loopGroupSizeLimit) {
	for(var i = loopGroups.length - 1; i >= 0; i--){
		var loopGroup = loopGroups[i];
		if(loopGroup.length > loopGroupSizeLimit) {
			loopGroups.splice(i, 1);
		}
	}
}

function createParLoopObj() {
	var parLoopObj = {};

	//standard info
	parLoopObj["id"] = "";
	parLoopObj["ompPragma"] = "";
	parLoopObj["isMainLoop"] = false;
	parLoopObj["parentLoopId"] = "";
	parLoopObj["origLine"] = -1;
	parLoopObj["nestedLevel"] = -1;
	parLoopObj["isInnermost"] = false;
	parLoopObj["isOutermost"] = false;
	parLoopObj["rank"] = [];
	parLoopObj["index"] = -1;

	//iteration info
	parLoopObj["maxIterations"] = 0;
	parLoopObj["minIterations"] = 0;
	parLoopObj["avgIterations"] = 0;
	parLoopObj["stdDevIterations"] = 0;
	parLoopObj["timesLoopIsCalled"] = 0;
	parLoopObj["hasIterationVariation"] = false;

	//parent iteration info
	parLoopObj["maxParentIterations"] = 0;
	parLoopObj["minParentIterations"] = 0;
	parLoopObj["avgParentIterations"] = 0;
	parLoopObj["stdDevParentIterations"] = 0;
	parLoopObj["hasParentIterationVariation"] = false;
	
	//instruction info
	parLoopObj["instructionInfo"] = {};

	//advanced info
	

	return parLoopObj;
}

function getParLoops(functionFilters) {
	Clava.pushAst();
	var loops = getLoopsFiltered(functionFilters, true);
	var pragmas = Parallelize.getForLoopsPragmas(loops, false, true);
	var loopIds = Object.keys(pragmas["parallelLoops"]);

	var parLoops = {};
	for(var loop of loops) {
		if(loopIds.includes(loop.id)) {
			var parLoop = createParLoopObj();
			var parentLoopId = "NULL";
			if(loop.nestedLevel > 0) {
				var $parentLoop = loop.ancestor("loop");
				if($parentLoop.kind == "for")
					parentLoopId = loop.ancestor("loop").id;
			}
			parLoop["id"] = loop.id;
			parLoop["ompPragma"] = pragmas["parallelLoops"][loop.id];
			parLoop["isMainLoop"] = false;
			parLoop["parentLoopId"] = parentLoopId;
			parLoops[loop.id] = parLoop;	

		}
	}
	
	Clava.popAst();
	return parLoops;
}

function getParLoopsFromExpectedOutput(params) {
	Clava.pushAst();
	rebuildCodeAst(params, params["xtraFiles"], params["xtraIncludeFolders"], true);
	var ompPragmas = getOmpPragmas();
	var benchmark = params["dynamic"]["benchmark"];

	var parLoops = {};
	for(var pragma of ompPragmas) {
		var $loop = pragma.target;
		var loopId = $loop.id;
		loopId = fixLoopId(loopId, benchmark);
		var parLoop = createParLoopObj();
		var parentLoopId = "NULL";
		if($loop.nestedLevel > 0) {
			var $parentLoop = $loop.ancestor("loop");
			if($parentLoop.kind == "for")
				parentLoopId = fixLoopId($loop.ancestor("loop").id, benchmark);
		}
		parLoop["id"] = loopId;
		parLoop["ompPragma"] = pragma.code;
		parLoop["isMainLoop"] = false;
		parLoop["parentLoopId"] = parentLoopId;
		parLoops[loopId] = parLoop;	
	}
	
	Clava.popAst();
	return parLoops;
}

function fixLoopId(loopId, benchmark) {
	var newLoopId = "";

	var lastSlashIndex = benchmark.c.lastIndexOf("/");
	var filename = benchmark.c.substr(lastSlashIndex + 1);
	var arrowIndex = loopId.indexOf("->");
	var restOfId = loopId.substr(arrowIndex);

	newLoopId = "file$" + filename + restOfId;

	return newLoopId;
}

function buildAndRun(params, version, nRuns, isPar) {
	var benchmark = params["dynamic"]["benchmark"];
	var problemSizeFlag = params["dynamic"]["problemSizeFlag"];
	var loopGroupSizeLimit = params["loopGroupSizeLimit"];

	var subFolder = "";
	if(isPar) {
		subFolder = "/par/" + loopGroupSizeLimit + "/" + version;
	}
	else
		subFolder = "/seq";
	
	var folder = Io.mkdir(benchmark.outputFolder + problemSizeFlag + subFolder);
	var buildFolder = Io.mkdir(benchmark.outputFolder + problemSizeFlag + subFolder + "/build");
	Clava.writeCode(folder);

	var cmaker = new CMaker(benchmark.name);

	cmaker.addCurrentAst();
	for(lib of params["compilationLibs"])
		cmaker.addLibs(lib);

	for(flag of params["compilationFlags"])
		cmaker.addFlags(flag);

	/*
	cmaker.addLibs("m");
	cmaker.addFlags("-O3");
	cmaker.addFlags("-mcmodel=medium");
	*/
	if(isPar)
		cmaker.addFlags("-fopenmp");

	var exe = cmaker.build(folder, buildFolder);

	var executors = [];
	var i;
	
	for(i = 0; i < nRuns; i++) {
		var executor = new ProcessExecutor();	
		executor.setPrintToConsole(false);
		executor.execute(exe.getAbsolutePath());
		executors.push(executor);
	}

	return executors;
}

function addPragmas(loopGroup, parLoops) {
	var $loopJps = getLoopsFromIds(loopGroup);

	if(loopGroup.length > 1) {
		var lowestNestedId = getLowestNestedLevel(loopGroup);
		var codeBefore = "omp_set_nested(1);";
		var codeAfter = "omp_set_nested(0);";
		$loopJps[lowestNestedId].insertBefore(codeBefore);
		$loopJps[lowestNestedId].insertAfter(codeAfter);
	}
	

	for(var loopId of loopGroup) {
		$loopJps[loopId].insertBefore(parLoops[loopId]["ompPragma"]);
	}
}

function getMainLoopIds(parLoops) {
	var mainLoopsIds = [];
	var parLoopIds = Object.keys(parLoops);
	for(var parLoopId of parLoopIds) {
		if(parLoops[parLoopId]["isMainLoop"])
			mainLoopsIds.push(parLoopId);
	}
	
	return mainLoopsIds;
}

function createBenchGroupResultsObj(loopGroupSizeLimit) {
	var benchGroupResultsObj = {};
	benchGroupResultsObj["loopGroupSizeLimit"] = loopGroupSizeLimit;
	benchGroupResultsObj["totalRuns"] = 0;
	benchGroupResultsObj["totalVersions"] = 0;
	benchGroupResultsObj["totalParLoops"] = 0;
	benchGroupResultsObj["totalExecutionTimeInSec"] = 0;
	benchGroupResultsObj["totalBenchmarks"] = 0;
	benchGroupResultsObj["totalBenchmarkVersions"] = 0;
	benchGroupResultsObj["benchmarks"] = [];

	return benchGroupResultsObj;
}

function createBenchResultsObj(benchmark, problemSizeFlag) {
	var benchResultsObj = {};
	benchResultsObj["benchmark"] = benchmark.folder;

	benchResultsObj["problemSizeFlag"] = problemSizeFlag;
	benchResultsObj["par"] = {};
	benchResultsObj["par"]["nVersions"] = 0;
	benchResultsObj["par"]["versions"] = [];
	benchResultsObj["seq"] = [];

	return benchResultsObj;
}


function concatFlags(flags) {
	var flagString = "";

	for(var flag of flags) {
		flagString += flag;
		flagString += " "; 
	}

	return flagString;
}

/**
searches for loops
@param functionFilters String[], ...
@param inclusive boolean, if true only retrieve loops inside the filtered functions
@return joinpoint[], ...
**/
function getLoopsFiltered(functionFilters, isInclusive) {
	var loops = [];

	for(var result of Query.search('function').search('loop').chain()) {
		var foundLoop = result["loop"];

		if(foundLoop.kind != "for")
			continue;
	
		var skip_loop = false;
		if(functionFilters.length > 0) {
			var skip_loop = isInclusive;
			for(var functionFilter of functionFilters) {
				if(result["function"].name.startsWith(functionFilter)) {
					skip_loop = !isInclusive;
					break;
				}
			}
		}		

		if(skip_loop)
			continue;
		
		loops.push(foundLoop);
	}
	
	return loops;
}

function getLoopsFromIds(loopIdFilters) {
	var loops = {};

	for(var result of Query.search('loop')) {
		var foundLoop = result;
		
		if(loopIdFilters.contains(foundLoop.id)) {
			loops[foundLoop.id] = foundLoop;
		}
	}
	
	return loops;
}

function getSubMainLoopId(loopGroup, parLoops) {
	var subMainLoopId = loopGroup[0];
	var $loopJps = getLoopsFromIds(loopGroup);
	var found = false;
	while(!found) {
		found = true;
		for(var loopId of loopGroup) {
			var subMainLoopRank = $loopJps[subMainLoopId].rank;
			var newLoopRank = $loopJps[loopId].rank;

			if(checkRankDescendant(loopId, newLoopRank)) {
				subMainLoopId = loopId;
				found = false;
			}
		}
	}

	return subMainLoopId;
}

function getOmpPragmas() {
	var ompPragmas = [];

	for(var result of Query.search('omp')) {
		ompPragmas.push(result);
	}
	return ompPragmas;
}

function getObjFromCache(params, objectName) {
	var benchmarkCacheFolder = params["dynamic"]["benchmark"].cacheFolder;
	var problemSizeFlag = params["dynamic"]["problemSizeFlag"];
	var loopGroupSizeLimit = params["loopGroupSizeLimit"];

	var path = benchmarkCacheFolder + problemSizeFlag + "/" + objectName + "-" + loopGroupSizeLimit + ".json";
	var obj = Io.readJson(path);

	return obj;
}

function writeObjToCache(params, objectName, obj) {
	var benchmarkCacheFolder = params["dynamic"]["benchmark"].cacheFolder;
	var problemSizeFlag = params["dynamic"]["problemSizeFlag"];
	var loopGroupSizeLimit = params["loopGroupSizeLimit"];

	var path = benchmarkCacheFolder + problemSizeFlag + "/" + objectName + "-" + loopGroupSizeLimit + ".json";
	Io.writeJson(path, obj);
}

function getLowestNestedLevel(loopGroup) {
	var lowestNestedId = loopGroup[0];
	var $loopJps = getLoopsFromIds(loopGroup);

	for(var loopId of loopGroup) {
		if($loopJps[loopId].nesteLevel < $loopJps[lowestNestedId].nesteLevel) {
			lowestNestedId = loopId;
		}
	}

	return lowestNestedId;
}

function testPragmas(parLoops, params) {
	var NO_TESTING = 0;
	var STRICTNESS_LOW = 1;
	var STRICTNESS_HIGH = 2;

	var test_strictness = params["clavaFlags"]["testPragmas"];

	var removedPragmas = {};
	if(test_strictness == NO_TESTING)
		return removedPragmas;
	
	loopIds = Object.keys(parLoops);
	$loops = getLoopsFromIds(loopIds);

	var nLoops = loopIds.length;
	println("Testing pragmas for problems");
	println("parLoops size before tests = " + nLoops);

	var counter = 0;
	for(loopId of loopIds) {
		var msg_prefix = counter + "/" + nLoops + " " + loopId;
	
		Clava.pushAst();

		if(test_strictness == STRICTNESS_LOW)
			$loops[loopId].insertAfter("exit(0);");
		addPragmas([loopId], parLoops);

		var executorPar = buildAndRun(params, "testPragmas", 1, true)[0];
		var returnValue = executorPar.getReturnValue();

		if(returnValue != 0) {
			removedPragmas[loopId] = parLoops[loopId];
			delete parLoops[loopId];
			println(msg_prefix + " pragma failed. Removing it from parLoops.");
		}
		else
			println(msg_prefix + " pragma passed sucessfully.");

		Clava.popAst();

		counter++;
	}

	println("parLoops size after tests = " + Object.keys(parLoops).length);

	return removedPragmas;
}

function updateDynamicParams(params, benchmark, problemSizeFlag, loopGroupSizeLimit) {
	params["dynamic"] = {};
	params["dynamic"]["benchmark"] = benchmark;
	params["dynamic"]["problemSizeFlag"] = problemSizeFlag;
	params["dynamic"]["preprocessorFlags"] = params["preprocessorFlags"];
	if(params["dynamic"]["problemSizeFlag"] != params["defaultFlag"]) {
		params["dynamic"]["preprocessorFlags"].push(problemSizeFlag);
	}
}

function checkEmptyParLoops(parLoops, params) {
	if(Object.keys(parLoops).length == 0) {
		writeObjToCache(params, "parLoops", parLoops);
		return true;
	}

	return false;
}