import clava.autopar.Parallelize;
import lara.Io;
import lara.util.LocalFolder;
import clava.ClavaJoinPoints;
import lara.cmake.CMaker;
import weaver.util.WeaverDataStore;
import lara.code.Timer;
import lara.metrics.ExecutionTimeMetric;
import weaver.Query;
import lara.Strings;

function getLoopIndexes(loopGroup, parLoops) {
	var indexes = [];
	for(var loopId of loopGroup) {
		indexes.push(parLoops[loopId]["index"]);
	}

	return indexes;
}

function countLoopIterations(benchmark, parLoops, problemSizeFlag, loopGroupSizeLimit) {
	var loopIds = Object.keys(parLoops);
	var newLoopIds = Array.from(loopIds);

	for(var loopId of loopIds) {
		if(parLoops[loopId]["parentLoopId"] != "NULL" && !newLoopIds.contains(parLoops[loopId]["parentLoopId"])) {
			newLoopIds.push(parLoops[loopId]["parentLoopId"]);
		}

	}
	
	Clava.pushAst();
	
	var $loops = getLoopsFromIds(newLoopIds);
	
	for(var loopId of newLoopIds) {
		var $loop = $loops[loopId];

		var loopPrefix = "iterations_" + loopId + "_";

		var codeLoop = "printf(\"" + loopPrefix + "%d\\n\", " + $loop.iterationsExpr.code + ");";
		$loop.insertBefore(codeLoop);
	}

	var executorSeq = buildAndRun(benchmark, -1, loopGroupSizeLimit, 1, false, problemSizeFlag)[0];
	var consoleOutput = executorSeq.getConsoleOutput();

	getLoopIterationStats(newLoopIds, parLoops, consoleOutput);

	Clava.popAst();
	
}

function getLoopIterationStats(newLoopIds, parLoops, consoleOutput) {
	var loopIterationObjs = {};

	for(var loopId of newLoopIds) {
		loopIterationObjs[loopId] = createLoopIterationObj();
	}

	var lines = consoleOutput.split("\n");
	for(var line of lines) {
		if(line.startsWith("iterations")) {
			var firstUnderScoreIndex = line.indexOf("_");
			var lastUnderScoreIndex = line.lastIndexOf("_");
			var loopId = line.slice(firstUnderScoreIndex + 1, lastUnderScoreIndex);
			var value = parseInt(line.substr(lastUnderScoreIndex + 1));

			loopIterationObjs[loopId]["instances"].push(value);
			loopIterationObjs[loopId]["avgIterations"] += value;
			if(loopIterationObjs[loopId]["firstInstance"]) {
				loopIterationObjs[loopId]["firstInstance"] = false;
				loopIterationObjs[loopId]["maxIterations"] = value;
				loopIterationObjs[loopId]["minIterations"] = value;
			}
			else {	
				if(value > loopIterationObjs[loopId]["maxIterations"]) {
					loopIterationObjs[loopId]["maxIterations"] = value;
				}
				if(value < loopIterationObjs[loopId]["minIterations"]) {
					loopIterationObjs[loopId]["minIterations"] = value;
				}
			}
		}
	}

	for(var loopId of newLoopIds) {
		loopIterationObjs[loopId]["avgIterations"] /= loopIterationObjs[loopId]["instances"].length;
		for(var value of loopIterationObjs[loopId]["instances"]) {
			loopIterationObjs[loopId]["stdDevIterations"] += Math.pow(value - loopIterationObjs[loopId]["avgIterations"] , 2);
		}
		loopIterationObjs[loopId]["stdDevIterations"] /= loopIterationObjs[loopId]["instances"].length;
		loopIterationObjs[loopId]["stdDevIterations"] = Math.sqrt(loopIterationObjs[loopId]["stdDevIterations"]);
	}	
	
	var parLoopIds = Object.keys(parLoops);
	
	for(var loopId of parLoopIds) {	
		parLoops[loopId]["maxIterations"] = loopIterationObjs[loopId]["maxIterations"];
		parLoops[loopId]["minIterations"] = loopIterationObjs[loopId]["minIterations"];
		parLoops[loopId]["avgIterations"] = loopIterationObjs[loopId]["avgIterations"];
		parLoops[loopId]["stdDevIterations"] = loopIterationObjs[loopId]["stdDevIterations"];

		var parentLoopId = parLoops[loopId]["parentLoopId"];
		if(parentLoopId != "NULL") {
			parLoops[loopId]["maxParentIterations"] = loopIterationObjs[parentLoopId]["maxIterations"];
			parLoops[loopId]["minParentIterations"] = loopIterationObjs[parentLoopId]["minIterations"];
			parLoops[loopId]["avgParentIterations"] = loopIterationObjs[parentLoopId]["avgIterations"];
			parLoops[loopId]["stdDevParentIterations"] = loopIterationObjs[parentLoopId]["stdDevIterations"];
			parLoops[loopId]["hasParentIterationVariation"] = loopIterationObjs[parentLoopId]["maxIterations"] != loopIterationObjs[parentLoopId]["minIterations"];
		}
		else {
			parLoops[loopId]["maxParentIterations"] = 1;
			parLoops[loopId]["minParentIterations"] = 1;
			parLoops[loopId]["avgParentIterations"] = 1;
			parLoops[loopId]["stdDevParentIterations"] = 0;
			parLoops[loopId]["hasParentIterationVariation"] = false;
		}
		
		parLoops[loopId]["timesLoopIsCalled"] = loopIterationObjs[loopId]["instances"].length;
		parLoops[loopId]["hasIterationVariation"] = loopIterationObjs[loopId]["maxIterations"] != loopIterationObjs[loopId]["minIterations"];
		
	}
	
	
}

function createLoopIterationObj() {
	var loopIterationObj = {};
	
	loopIterationObj["maxIterations"] = 0;
	loopIterationObj["minIterations"] = 0;
	loopIterationObj["avgIterations"] = 0;
	loopIterationObj["stdDevIterations"] = 0;
	loopIterationObj["firstInstance"] = true;
	loopIterationObj["instances"] = [];

	return loopIterationObj;
}

function getLoopInfo(parLoops) {
	var parLoopIds = Object.keys(parLoops);
	var $loopJps = getLoopsFromIds(parLoopIds);

	var index = 0;
	for(var loopId of parLoopIds) {
		var $loop = $loopJps[loopId];
		var loopInstructionInfo = getInstructionInfo($loop);
		
		parLoops[loopId]["origLine"] = $loop.line;
		parLoops[loopId]["nestedLevel"] = $loop.nestedLevel;
		parLoops[loopId]["isInnermost"] = $loop.isInnermost;
		parLoops[loopId]["isOutermost"] = $loop.isOutermost;
		parLoops[loopId]["rank"] = Array.from($loop.rank);
		parLoops[loopId]["index"] = index;
		
		parLoops[loopId]["instructionInfo"] = loopInstructionInfo;
		
		index++;
	}
}

function addLoopInfo(parLoops, benchmarkResults) {
	benchmarkResults["nLoops"] = parLoops.length;
	benchmarkResults["loops"] = {};
	var parLoopIds = Object.keys(parLoops);
	
	for(var loopId of parLoopIds) {
		var index = parLoops[loopId]["index"];	
		benchmarkResults["loops"][index] = parLoops[loopId];
	}
}

function createInstructionInfoObj() {
	var instructionInfo = {};
	
	//joinpoints found
	instructionInfo["joinpoints"] = {};
	instructionInfo["joinpoints"]["arrayAccess"] = 0;
	instructionInfo["joinpoints"]["binaryOp"] = 0;
	instructionInfo["joinpoints"]["call"] = 0;
	instructionInfo["joinpoints"]["cast"] = 0;
	instructionInfo["joinpoints"]["decl"] = 0;
	instructionInfo["joinpoints"]["declarator"] = 0;
	instructionInfo["joinpoints"]["deleteExpr"] = 0;
	instructionInfo["joinpoints"]["enumDecl"] = 0;
	instructionInfo["joinpoints"]["enumeratorDecl"] = 0;
	instructionInfo["joinpoints"]["expression"] = 0;
	instructionInfo["joinpoints"]["if"] = 0;
	instructionInfo["joinpoints"]["loop"] = 0;
	instructionInfo["joinpoints"]["memberAccess"] = 0;
	instructionInfo["joinpoints"]["memberCall"] = 0;
	instructionInfo["joinpoints"]["namedDecl"] = 0;
	instructionInfo["joinpoints"]["newExpr"] = 0;
	instructionInfo["joinpoints"]["op"] = 0;
	instructionInfo["joinpoints"]["returnStmt"] = 0;
	instructionInfo["joinpoints"]["statement"] = 0;
	instructionInfo["joinpoints"]["typeDefDecl"] = 0;
	instructionInfo["joinpoints"]["typeDefNameDecl"] = 0;
	instructionInfo["joinpoints"]["unaryExprOrType"] = 0;
	instructionInfo["joinpoints"]["unaryOp"] = 0;
	instructionInfo["joinpoints"]["vardecl"] = 0;
	instructionInfo["joinpoints"]["varref"] = 0;
	instructionInfo["totalJoinpoints"] = 0;

	//derived info from joinpoints found
	//arrayAccess
	instructionInfo["arrayAccessRead"] = 0;
	instructionInfo["arrayAccessWrite"] = 0;
	instructionInfo["arrayAccessReadWrite"] = 0;

	//binaryOp
	instructionInfo["binaryOpArithmetic"] = 0;
	instructionInfo["binaryOpLogic"] = 0;
	instructionInfo["binaryOpComparison"] = 0;
	instructionInfo["binaryOpAssignment"] = 0;
	instructionInfo["binaryOpBitwise"] = 0;
	instructionInfo["binaryOpBitwiseAssignment"] = 0;
	instructionInfo["binaryOpArithmeticAssignment"] = 0;

	//unaryOp
	instructionInfo["unaryOpArithmetic"] = 0;
	instructionInfo["unaryOpLogic"] = 0;
	instructionInfo["unaryOpComparison"] = 0;
	instructionInfo["unaryOpAssignment"] = 0;
	instructionInfo["unaryOpBitwise"] = 0;
	instructionInfo["unaryOpBitwiseAssignment"] = 0;
	instructionInfo["unaryOpArithmeticAssignment"] = 0;

	//binaryOp + unaryOp
	instructionInfo["totalArithmetic"] = 0;
	instructionInfo["totalLogic"] = 0;
	instructionInfo["totalComparison"] = 0;
	instructionInfo["totalAssignment"] = 0;
	instructionInfo["totalBitwise"] = 0;
	instructionInfo["totalBitwiseAssignment"] = 0;
	instructionInfo["totalArithmeticAssignment"] = 0;

	//call + memberCall
	instructionInfo["callAvgNumberArgs"] = 0;
	instructionInfo["callExternal"] = 0;
	instructionInfo["callLevel0"] = 0;
	instructionInfo["callNested"] = 0;
	instructionInfo["callFunction"] = 0;
	instructionInfo["callMethod"] = 0;
	instructionInfo["callInnerJps"] = 0;
	instructionInfo["callRecursive"] = 0;

	//cast
	instructionInfo["castImplicit"] = 0;
	instructionInfo["castExplicit"] = 0;

	//loop
	instructionInfo["loopFor"] = 0;
	instructionInfo["loopWhile"] = 0;
	instructionInfo["loopDoWhile"] = 0;
	instructionInfo["loopForEach"] = 0;

	//memberAccess
	instructionInfo["memberAccessRead"] = 0;
	instructionInfo["memberAccessWrite"] = 0;
	instructionInfo["memberAccessReadWrite"] = 0;

	//vardecl
	instructionInfo["vardeclHasInit"] = 0;
	instructionInfo["vardeclGlobal"] = 0;
	instructionInfo["vardeclParam"] = 0;

	//varref
	instructionInfo["varrefRead"] = 0;
	instructionInfo["varrefWrite"] = 0;
	instructionInfo["varrefReadWrite"] = 0;	

	return instructionInfo;
}

function getInstructionInfo($loop) {
	var instructionInfo = createInstructionInfoObj();
	instructionAnalyser($loop, instructionInfo);

	//var functionInstructionInfo = createInstructionInfoObj();
	//functionAnalyser($loop, functionInstructionInfo);
	callAnalyser($loop, instructionInfo);

	//joinInstructionInfoObjs(instructionInfo, functionInstructionInfo);

	return instructionInfo;
}

function getJPDescendants($jp, instructionInfo) {
	var jpTypes = Object.keys(instructionInfo["joinpoints"]);
	var $descendants = {};

	for(var jpType of jpTypes) {
		$descendants[jpType] = $jp.descendants(jpType);
		instructionInfo["joinpoints"][jpType] += $descendants[jpType].length;
		instructionInfo["totalJoinpoints"] += $descendants[jpType].length;
	}

	return $descendants;
}

function callAnalyser($loop, instructionInfo) {
	var $calls = $loop.descendants("call");

	for(var $call of $calls) {
		instructionInfo["callLevel0"] += 1;
		instructionInfo["callAvgNumberArgs"] += $call.numArgs;
		
		if($call.instanceOf("memberCall"))
			instructionInfo["callMethod"] += 1;
		else
			instructionInfo["callFunction"] += 1;
	
		var $function = $call.function;
		var functionId = $function.id;
		var $functionDefinition = $function.definitionJp;

		if(typeof $functionDefinition === "undefined") {
			instructionInfo["callExternal"] += 1;
			continue;
		}

		var callStack = [];
		callAnalyserAux($functionDefinition, functionId, callStack, instructionInfo);	
	}
	if(instructionInfo["joinpoints"]["call"] > 0)
		instructionInfo["callAvgNumberArgs"] /= instructionInfo["joinpoints"]["call"];
}

function callAnalyserAux($functionDefinition, functionId, callStack, instructionInfo) {
	if(callStack.contains(functionId)) {
		instructionInfo["callRecursive"] += 1;
		return;
	}

	var nFoundJps = instructionAnalyser($functionDefinition, instructionInfo);
	instructionInfo["callInnerJps"] += nFoundJps;

	var $calls = $functionDefinition.descendants("call");

	for(var $call of $calls) {
		instructionInfo["callNested"] += 1;

		if($call.instanceOf("memberCall"))
			instructionInfo["callMethod"] += 1;
		else
			instructionInfo["callFunction"] += 1;
	
		var $function = $call.function;
		var functionId = $function.id;
		//println(functionId);
		var $functionDefinition = $function.definitionJp;

		if(typeof $functionDefinition === "undefined") {
			instructionInfo["callExternal"] += 1;
			continue;
		}
		
		var callStack = Array.from(callStack);
		callStack.push(functionId);

		callAnalyserAux($functionDefinition, functionId, callStack, instructionInfo);
	}

	return;
}

function instructionAnalyser($jp, instructionInfo) {
	var $descendants = getJPDescendants($jp, instructionInfo);
	
	arrayAccessesAnalyzer($descendants, instructionInfo);
	unaryBinaryOpsAnalyzer($descendants, instructionInfo);
	castAnalyzer($descendants, instructionInfo);
	loopAnalyzer($descendants, instructionInfo);
	memberAccessAnalyzer($descendants, instructionInfo);
	vardeclAnalyzer($descendants, instructionInfo);
	varrefAnalyzer($descendants, instructionInfo);

	var totalDescendants = countDescendants($descendants);

	return totalDescendants;
}

function countDescendants($descendants) {
	var sum = 0;
	var keys = Object.keys($descendants);

	for(var key of keys) {
		sum += $descendants[key].length;
	}

	return sum;
}

function arrayAccessesAnalyzer($descendants, instructionInfo) {
	for(var $arrayAccess of $descendants["arrayAccess"]) {
		var use = $arrayAccess.use;
		switch(use) {
			case "read":
				instructionInfo["arrayAccessRead"] += 1;
				break;
			case "write":
				instructionInfo["arrayAccessWrite"] += 1;
				break;
			case "readwrite":
				instructionInfo["arrayAccessReadWrite"] += 1;
				break;
		}
	}
}

function unaryBinaryOpsAnalyzer($descendants, instructionInfo) {
	var arithmeticOperators = ["+", "-", "*", "/", "%", "++", "--"];
	var logicOperators = ["||", "&&", "!"];
	var comparisonOperators = ["==", "!=", "<", "<=", ">", ">="];
	var assignmentOperators = ["="];
	var bitwiseOperators = ["&", "|", "^", "~", "<<", ">>"];
	var arithmeticAssignmentOperators = ["+=", "-=", "*=", "/=", "%="];
	var bitwiseAssignmentOperators = ["&=", "|=", "^=", ">>=", "<<="];

	for(var $binaryOp of $descendants["binaryOp"]) {
		if(arithmeticOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpArithmetic"] += 1;
			instructionInfo["totalArithmetic"] += 1;
		}
		else if(logicOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpLogic"] += 1;
			instructionInfo["totalLogic"] += 1;
		}
		else if(comparisonOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpComparison"] += 1;
			instructionInfo["totalComparison"] += 1;
		}
		else if(assignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
		}
		else if(bitwiseOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpBitwise"] += 1;
			instructionInfo["totalBitwise"] += 1;
		}
		else if(bitwiseAssignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpBitwiseAssignment"] += 1;
			instructionInfo["binaryOpBitwise"] += 1;
			instructionInfo["binaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
			instructionInfo["totalBitwise"] += 1;
			instructionInfo["totalBitwiseAssignment"] += 1;
		}
		else if(arithmeticAssignmentOperators.contains($binaryOp.operator)) {
			instructionInfo["binaryOpArithmeticAssignment"] += 1;
			instructionInfo["binaryOpArithmetic"] += 1;
			instructionInfo["binaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
			instructionInfo["totalArithmetic"] += 1;
			instructionInfo["totalArithmeticAssignment"] += 1;
		}
		
	}

	for(var $unaryOp of $descendants["unaryOp"]) {
		if(arithmeticOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpArithmetic"] += 1;
			instructionInfo["totalArithmetic"] += 1;
		}
		else if(logicOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpLogic"] += 1;
			instructionInfo["totalLogic"] += 1;
		}
		else if(comparisonOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpComparison"] += 1;
			instructionInfo["totalComparison"] += 1;
		}
		else if(assignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
		}
		else if(bitwiseOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpBitwise"] += 1;
			instructionInfo["totalBitwise"] += 1;
		}
		else if(bitwiseAssignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpBitwiseAssignment"] += 1;
			instructionInfo["unaryOpBitwise"] += 1;
			instructionInfo["unaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
			instructionInfo["totalBitwise"] += 1;
			instructionInfo["totalBitwiseAssignment"] += 1;
		}
		else if(arithmeticAssignmentOperators.contains($unaryOp.operator)) {
			instructionInfo["unaryOpArithmeticAssignment"] += 1;
			instructionInfo["unaryOpArithmetic"] += 1;
			instructionInfo["unaryOpAssignment"] += 1;
			instructionInfo["totalAssignment"] += 1;
			instructionInfo["totalArithmetic"] += 1;
			instructionInfo["totalArithmeticAssignment"] += 1;
		}
	}
}

function castAnalyzer($descendants, instructionInfo) {
	for(var $cast of $descendants["cast"]) {
		if(typeof $cast.implicitCast === "undefined")
			instructionInfo["castExplicit"] += 1;
		else
			instructionInfo["castImplicit"] += 1;
	}
}

function loopAnalyzer($descendants, instructionInfo) {
	for(var $loop of $descendants["loop"]) {
		var kind = $loop.kind;
		switch(kind) {
			case "for":
				instructionInfo["loopFor"] += 1;
				break;
			case "while":
				instructionInfo["loopWhile"] += 1;
				break;
			case "dowhile":
				instructionInfo["loopDoWhile"] += 1;
				break;
			case "foreach":
				instructionInfo["loopForEach"] += 1;
				break;
		}
	}
}

function memberAccessAnalyzer($descendants, instructionInfo) {
	for(var $memberAccess of $descendants["memberAccess"]) {
		var use = $memberAccess.use;
		switch(use) {
			case "read":
				instructionInfo["memberAccessRead"] += 1;
				break;
			case "write":
				instructionInfo["memberAccessWrite"] += 1;
				break;
			case "readwrite":
				instructionInfo["memberAccessReadWrite"] += 1;
				break;
		}
	}
}

function vardeclAnalyzer($descendants, instructionInfo) {
	for(var $vardecl of $descendants["vardecl"]) {
		if($vardecl.hasInit)
			instructionInfo["vardeclHasInit"] += 1;
		if($vardecl.isGlobal)
			instructionInfo["vardeclGlobal"] += 1;
		if($vardecl.isParam)
			instructionInfo["vardeclParam"] += 1;
	}
}

function varrefAnalyzer($descendants, instructionInfo) {
	for(var $varref of $descendants["varref"]) {
		var use = $varref.use;
		switch(use) {
			case "read":
				instructionInfo["varrefRead"] += 1;
				break;
			case "write":
				instructionInfo["varrefWrite"] += 1;
				break;
			case "readwrite":
				instructionInfo["varrefReadWrite"] += 1;
				break;
		}
	}
}


//TODO atualizar isto
/*
function joinInstructionInfoObjs(instructionInfo, functionInstructionInfo) {
	instructionInfo["externalFuncionCalls"] = functionInstructionInfo["externalFuncionCalls"];
	instructionInfo["level0FunctionCalls"] = functionInstructionInfo["level0FunctionCalls"];
	instructionInfo["nestedFunctionCalls"] = functionInstructionInfo["nestedFunctionCalls"];
	instructionInfo["totalFunctionCalls"] = functionInstructionInfo["totalFunctionCalls"];
	instructionInfo["recursiveFunctionCalls"] = functionInstructionInfo["recursiveFunctionCalls"];


	instructionInfo["arithmeticInstructions"] += functionInstructionInfo["arithmeticInstructions"];
	instructionInfo["logicInstructions"] += functionInstructionInfo["logicInstructions"];
	instructionInfo["comparisonInstructions"] += functionInstructionInfo["comparisonInstructions"];
	instructionInfo["assignmentInstructions"] += functionInstructionInfo["assignmentInstructions"];
	instructionInfo["bitwiseInstructions"] += functionInstructionInfo["bitwiseInstructions"];
	instructionInfo["ifInstructions"] += functionInstructionInfo["ifInstructions"];
	instructionInfo["loopInstructions"] += functionInstructionInfo["loopInstructions"];
	instructionInfo["varDeclarationInstructions"] += functionInstructionInfo["varDeclarationInstructions"];
	instructionInfo["arrayAccessInstructions"] += functionInstructionInfo["arrayAccessInstructions"];
	instructionInfo["totalInstructions"] += functionInstructionInfo["totalInstructions"];
	instructionInfo["functionInstructions"] = functionInstructionInfo["totalInstructions"];
	
}
*/

function getLoopIds($loops) {
	var loopIds = [];

	for (var $loop of $loops) {
		loopIds.push($loop.id);
	}

	return loopIds;
}

function addResults(benchmarkResults, measures, executors, version, loopGroup, parLoops) {
	var isPar = version >= 0;
	
	//var loopIds = Object.keys(parLoops);
	var loopIndexes = getLoopIndexes(loopGroup, parLoops);
	var mainLoopIds = getMainLoopIds(parLoops);
	var mainLoopIndexes = getLoopIndexes(mainLoopIds, parLoops);

	var name = "";
	var info = {};
	if (isPar) {
		name = "par";
		benchmarkResults["par"]["nVersions"] += 1;
		info["version"] = version;
		info["parLoops"] = Array.from(loopIndexes);
		info["mainLoop"] = 0;
		info["measures"] = [];
	}
	else
		name = "seq";

	for(var measure of measures) {
		var measureInfo = {};
		measureInfo["loopIndex"] = parseInt(measure._prefix);
		measureInfo["runs"] = [];
		var runId = 0;
		for(var executor of executors) {
			var res = measure.report(executor);
			var newRes = {};
			newRes.value = res.getValue();
			newRes.unit = res.getUnit();
			measureInfo["runs"].push(newRes);
			runId++;
		}

		if(isPar) {
			info["measures"].push(measureInfo);
			if(mainLoopIndexes.includes(parseInt(measure._prefix)))
				info["mainLoop"] = parseInt(measure._prefix);
		}
		else {
			benchmarkResults["seq"].push(measureInfo);
		}
	}

	if(isPar) {
		benchmarkResults["par"]["versions"].push(info);
	}
	
}

function getSubFolders(sourceFolder, benchmarkFolders, allFolders, excludedFiles, excludedFolders) {
	if (benchmarkFolders.length == 1 && benchmarkFolders[0] == "all")
		benchmarkFolders = allFolders;

	var benchmarks = [];
	var foldersChecked = [];

	for (var folder of benchmarkFolders) {
		var folderPath = sourceFolder + folder;
		
		if(!Io.isFolder(folderPath)) {
			println(folderPath + " is not a valid folder.");
			continue;
		}

		var folder = new LocalFolder(folderPath);
		var fileList = folder.getFileList();

		for (var file of fileList) {
			var fileString = file.toString();
			if(!fileString.endsWith(".c"))
				continue;

			var skipFile = false;
			for(var excludedFile of excludedFiles) {
				if(fileString.endsWith(excludedFile)) {
					skipFile = true;
					break;
				}
			}

			if(skipFile)
				continue;

			var benchmark = createBenchmarkObj(fileString);

			for(excludedFolder of excludedFolders) {
				if(benchmark.folder.endsWith(excludedFolder))
				skipFile = true;
			}

			if(skipFile)
				continue;
	
			
			if(foldersChecked.contains(benchmark.folder))
				continue;

			benchmarks.push(benchmark);
			foldersChecked.push(benchmark.folder);

		}
	}
	return benchmarks;
}

function createBenchmarkObj(fileString) {
	var benchmark = new Object();

	var lastSlash = fileString.lastIndexOf("/");
	var benchGroupNameIndex = fileString.indexOf("/sources/") + 9;
	benchmark.c = Io.getAbsolutePath(fileString);
	benchmark.folder = Io.getAbsolutePath(fileString.slice(0, lastSlash));
	benchmark.cacheFolder = Io.getAbsolutePath("./cache/" + fileString.slice(benchGroupNameIndex, lastSlash));
	benchmark.outputFolder = Io.getAbsolutePath("./outputs/" + fileString.slice(benchGroupNameIndex, lastSlash));

	var lastSlashFolder = benchmark.folder.lastIndexOf("/");
	benchmark.name = benchmark.folder.substring(lastSlashFolder + 1);

	return benchmark;
}

function rebuildCodeAst(benchmark, xtraCs, xtraIncludeFolders, flags) {
	var includeFolders = Array.from(xtraIncludeFolders);
	includeFolders.push(benchmark.folder);

	var dataStore = Clava.getData();
	dataStore.setUserIncludes(includeFolders);
	var flagString = concatFlags(flags);
	dataStore.setFlags(flagString);

	var cs = Array.from(xtraCs);
	cs.push(benchmark.c);
	
	for(var c of cs) {
		var clavaJPFile = ClavaJoinPoints.file(c);
		Clava.addFile(clavaJPFile);
	}

	Clava.rebuild();
}

function addTimerSeq(parallelLoopIds, parLoops) {

	var measures = [];

	for(var result of Query.search('function').search('loop').chain()) {
		if(!parallelLoopIds.includes(result["loop"].id)) {
			continue;
		}

		var measure = new CustomExecutionTimeMetric(parLoops[result["loop"].id]["index"].toString());
		measures.push(measure);
		
		measure.instrument(result["loop"]);
	}

	return measures;
}

function addTimerMainLoop(mainLoopId, mainLoopIndex) {
	var measure;
	for(var result of Query.search('function').search('loop').chain()) {
		if(result["loop"].id != mainLoopId) {
			continue;
		}

		measure = new CustomExecutionTimeMetric(mainLoopIndex);	
		measure.instrument(result["loop"], undefined, true);
		break;
	}
	return measure;
}

function addTimerPar(loopGroup, parLoops) {
	var measures = [];
	//var loopGroupIds = getLoopIds($loopGroup);
	var $loopJps = getLoopsFromIds(loopGroup);
	var mainLoopIds = getMainLoopIds(parLoops);
	var foundMainLoop = false;

	for(var result of Query.search('pragma')) {
		if(result.name != "omp")
			continue;

		var $pragmaLoop = result.target;
		if(!loopGroup.includes($pragmaLoop.id))
			continue;
		
		var measurePrefix = parLoops[$pragmaLoop.id]["index"].toString();
		var measure = new CustomExecutionTimeMetric(measurePrefix);
		measures.push(measure);

		var addExitStatement = false;
		if(mainLoopIds.includes($pragmaLoop.id)) {
			addExitStatement = true;
			foundMainLoop = true;
		}
		
		measure.instrument(result, $pragmaLoop, addExitStatement);
		
	}

	if(!foundMainLoop) {
		var subMainLoopId = getSubMainLoopId(loopGroup, parLoops);
		var mainLoopMeasure = findAndTimeMainLoop(subMainLoopId, parLoops, mainLoopIds);
		measures.push(mainLoopMeasure);
	}

	
	//println("measures.length = " + measures.length);
	//println("measure[0]._prefix = " + measures[0]._prefix);

	//exit(0);

	return measures;
}

function findAndTimeMainLoop(subMainLoopId, parLoops, mainLoopIds) {
	var $subMainLoop = getLoopsFromIds([subMainLoopId])[subMainLoopId];
	var $mainLoopJps = getLoopsFromIds(mainLoopIds);
	var mainLoopMeasure;
	for(var mainLoopId of mainLoopIds) {
		var $mainLoop = $mainLoopJps[mainLoopId];
		if(checkRankDescendant($subMainLoop.rank, $mainLoop.rank)) {
			var mainLoopIndex = parLoops[$mainLoop.id]["index"].toString();
			mainLoopMeasure = addTimerMainLoop($mainLoop.id, mainLoopIndex);
		}
	}

	return mainLoopMeasure;
}

/**
checks if loop with the rank loopRank0 is descendant from the loop with the rank loopRank1
@param loopRank0 int[], rank from loop we intend to check
@param loopRank1 int[], rank from loop we intend to check against
@return true if loop with the rank loopRank0 is descendant from the loop with the rank loopRank1
**/
function checkRankDescendant(loopRank0, loopRank1) {
	if(loopRank0.length <= loopRank1.length)
		return false;
	
	for(var i = 0; i < loopRank1.length; i++) {
		if(loopRank1[i] != loopRank0[i])
			return false;
	}

	return true;
}

function getParLoopGroups(parLoops, loopGroupSizeLimit) {
	var loopGroups = [];
	var processedIds = [];
	var parLoopIds = Object.keys(parLoops);
	var $loopJps = getLoopsFromIds(parLoopIds);
	var currLvl = 0;

	while(processedIds.length < parLoopIds.length) {

		for(var loopId of parLoopIds) {
			var $loop = $loopJps[loopId];
		
			if($loop.nestedLevel != currLvl || processedIds.includes(loopId))
				continue;
		
			var currentGroup = [];
			currentGroup.push([loopId]);
			processedIds.push(loopId);
			parLoops[loopId]["isMainLoop"] = true;
			
			var $loopDescendants = $loop.descendants("loop");
			for(var $descendant of $loopDescendants) {
				if(!parLoopIds.includes($descendant.id)) {
					continue;
				}

				processedIds.push($descendant.id);
				var toAdd = [];
				for(var loops of currentGroup) {
					var newLoops = Array.from(loops);
					newLoops.push($descendant.id);
					toAdd.push(newLoops);
				}

				for(var elem of toAdd) {
					currentGroup.push(elem);
				}

				currentGroup.push([$descendant.id]);
			}
	
			for(var elem of currentGroup) {
				loopGroups.push(elem);
			}
			
		}

		currLvl += 1;
		
	}

	filterLoopGroups(loopGroups, loopGroupSizeLimit);

	return loopGroups;
}

function filterLoopGroups(loopGroups, loopGroupSizeLimit) {
	for(var i = loopGroups.length - 1; i >= 0; i--){
		var loopGroup = loopGroups[i];
		if(loopGroup.length > loopGroupSizeLimit) {
			loopGroups.splice(i, 1);
		}
	}
}

function createParLoopObj() {
	var parLoopObj = {};

	//standard info
	parLoopObj["id"] = "";
	parLoopObj["ompPragma"] = "";
	parLoopObj["isMainLoop"] = false;
	parLoopObj["parentLoopId"] = "";
	parLoopObj["origLine"] = -1;
	parLoopObj["nestedLevel"] = -1;
	parLoopObj["isInnermost"] = false;
	parLoopObj["isOutermost"] = false;
	parLoopObj["rank"] = [];
	parLoopObj["index"] = -1;

	//iteration info
	parLoopObj["maxIterations"] = -1;
	parLoopObj["minIterations"] = -1;
	parLoopObj["avgIterations"] = -1;
	parLoopObj["stdDevIterations"] = -1;
	parLoopObj["hasIterationVariation"] = false;

	//parent iteration info
	parLoopObj["maxParentIterations"] = -1;
	parLoopObj["minParentIterations"] = -1;
	parLoopObj["avgParentIterations"] = -1;
	parLoopObj["stdDevParentIterations"] = -1;
	parLoopObj["timesLoopIsCalled"] = -1;
	parLoopObj["hasParentIterationVariation"] = false;
	
	//instruction info
	parLoopObj["instructionInfo"] = {};

	//advanced info
	

	return parLoopObj;
}

function getParLoops(functionFilters) {
	var loops = getLoopsFiltered(functionFilters);
	
	Parallelize.forLoops(loops);

	var pragmas = Parallelize.getForLoopsPragmas(loops);
	var astIds = Object.keys(pragmas["parallelLoops"]);

	var parLoops = {};
	for(var loop of loops) {
		if(astIds.includes(loop.astId)) {
			var parLoop = createParLoopObj();
			var parentLoopId = "NULL";
			if(loop.nestedLevel > 0) {
				parentLoopId = loop.ancestor("loop").id;
			}
			parLoop["id"] = loop.id;
			parLoop["ompPragma"] = pragmas["parallelLoops"][loop.astId];
			parLoop["isMainLoop"] = false;
			parLoop["parentLoopId"] = parentLoopId;
			parLoops[loop.id] = parLoop;		
		}
	}
	
	return parLoops;
}

function getParLoopsFromPrevOutput(benchmark, xtraCs, xtraIncludeFolders, flags) {
	var parLoops = {};
	Clava.pushAst();

	//copied from rebuildCodeAst()
	var includeFolders = Array.from(xtraIncludeFolders);
	includeFolders.push(benchmark.folder);

	var dataStore = Clava.getData();
	dataStore.setUserIncludes(includeFolders);
	var flagString = concatFlags(flags);
	dataStore.setFlags(flagString);

	var cs = Array.from(xtraCs);
	var expectedCPath = benchmark.folder + "/expected_output.c";
	cs.push(expectedCPath);
	
	for(var c of cs) {
		var clavaJPFile = ClavaJoinPoints.file(c);
		Clava.addFile(clavaJPFile);
	}

	Clava.rebuild();

	var ompPragmas = getOmpPragmas();

	for(var pragma of ompPragmas) {
		var $loop = pragma.target;
		var loopId = $loop.id;
		loopId = fixLoopId(loopId, benchmark);
		var parLoop = {};
		var parentLoopId = "NULL";
		if($loop.nestedLevel > 0) {
			parentLoopId = fixLoopId($loop.ancestor("loop").id, benchmark);
		}
		parLoop["id"] = loopId;
		parLoop["ompPragma"] = pragma.code;
		parLoop["isMainLoop"] = false;
		parLoop["parentLoopId"] = parentLoopId;
		parLoops[loopId] = parLoop;	
	}
	
	Clava.popAst();
	return parLoops;
}

function fixLoopId(loopId, benchmark) {
	var newLoopId = "";

	var lastSlashIndex = benchmark.c.lastIndexOf("/");
	var filename = benchmark.c.substr(lastSlashIndex + 1);
	var arrowIndex = loopId.indexOf("->");
	var restOfId = loopId.substr(arrowIndex);

	newLoopId = "file$" + filename + restOfId;

	return newLoopId;
}

function buildAndRun(benchmark, version, loopGroupSizeLimit, nRuns, isPar, problemSizeFlag) {
	var subFolder = "";
	
	if(isPar) {
		subFolder = "/par/" + loopGroupSizeLimit + "/" + version;
	}
	else
		subFolder = "/seq";
	
	var folder = Io.mkdir(benchmark.outputFolder + problemSizeFlag + subFolder);
	var buildFolder = Io.mkdir(benchmark.outputFolder + problemSizeFlag + subFolder + "/build");
	Clava.writeCode(folder);

	var cmaker = new CMaker(benchmark.name);

	cmaker.addCurrentAst();
	cmaker.addLibs("m");
	cmaker.addFlags("-O3");	
	if(isPar)
		cmaker.addFlags("-fopenmp");

	var exe = cmaker.build(folder, buildFolder);

	var executors = [];
	var i;
	
	for(i = 0; i < nRuns; i++) {
		var executor = new ProcessExecutor();	
		executor.setPrintToConsole(false);
		var exeOutput = executor.execute(exe.getAbsolutePath());
		executors.push(executor);
	}

	return executors;
}

function addPragmas(loopGroup, parLoops) {
	var $loopJps = getLoopsFromIds(loopGroup);

	if(loopGroup.length > 1) {
		var lowestNestedId = getLowestNestedLevel(loopGroup);
		var codeBefore = "omp_set_nested(1);";
		var codeAfter = "omp_set_nested(0);";
		$loopJps[lowestNestedId].insertBefore(codeBefore);
		$loopJps[lowestNestedId].insertAfter(codeAfter);
	}
	

	for(var loopId of loopGroup) {
		$loopJps[loopId].insertBefore(parLoops[loopId]["ompPragma"]);
	}
}

function getMainLoopIds(parLoops) {
	var mainLoopsIds = [];
	var parLoopIds = Object.keys(parLoops);
	for(var parLoopId of parLoopIds) {
		if(parLoops[parLoopId]["isMainLoop"])
			mainLoopsIds.push(parLoopId);
	}
	
	return mainLoopsIds;
}

function createBenchGroupResultsObj(nRuns, loopGroupSizeLimit) {
	var benchGroupResultsObj = {};
	benchGroupResultsObj["loopGroupSizeLimit"] = loopGroupSizeLimit;
	benchGroupResultsObj["runsPerVersion"] = nRuns;
	benchGroupResultsObj["totalRuns"] = 0;
	benchGroupResultsObj["totalVersions"] = 0;
	benchGroupResultsObj["totalParLoops"] = 0;
	benchGroupResultsObj["totalExecutionTimeInSec"] = 0;
	benchGroupResultsObj["totalBenchmarks"] = 0;
	benchGroupResultsObj["totalBenchmarkVersions"] = 0;
	benchGroupResultsObj["benchmarks"] = [];

	return benchGroupResultsObj;
}

function createBenchResultsObj(benchmark, problemSizeFlag) {
	var benchResultsObj = {};
	benchResultsObj["benchmark"] = benchmark.folder;

	benchResultsObj["problemSizeFlag"] = problemSizeFlag;
	benchResultsObj["par"] = {};
	benchResultsObj["par"]["nVersions"] = 0;
	benchResultsObj["par"]["versions"] = [];
	benchResultsObj["seq"] = [];

	return benchResultsObj;
}


function concatFlags(flags) {
	var flagString = "";

	for(var flag of flags) {
		flagString += flag;
		flagString += " "; 
	}

	return flagString;
}

function getLoopsFiltered(functionFilters) {
	var loops = [];

	for(var result of Query.search('function').search('loop').chain()) {
		var foundLoop = result["loop"];
	
		var skip_loop = false;
		if(functionFilters.length > 0) {
			var skip_loop = true;
			for(var functionFilter of functionFilters) {
				if(result["function"].name.startsWith(functionFilter)) {
					skip_loop = false;
					break;
				}
			}
		}		

		if(skip_loop)
			continue;
		
		loops.push(foundLoop);
	}
	
	return loops;
}

function getLoopsFromIds(loopIdFilters) {
	var loops = {};

	for(var result of Query.search('loop')) {
		var foundLoop = result;
		
		if(loopIdFilters.contains(foundLoop.id)) {
			loops[foundLoop.id] = foundLoop;
		}
	}
	
	return loops;
}

function getSubMainLoopId(loopGroup, parLoops) {
	var subMainLoopId = loopGroup[0];
	var $loopJps = getLoopsFromIds(loopGroup);
	var found = false;
	while(!found) {
		found = true;
		for(var loopId of loopGroup) {
			var subMainLoopRank = $loopJps[subMainLoopId].rank;
			var newLoopRank = $loopJps[loopId].rank;

			if(checkRankDescendant(loopId, newLoopRank)) {
				subMainLoopId = loopId;
				found = false;
			}
		}
	}

	return subMainLoopId;
}

function getOmpPragmas() {
	var ompPragmas = [];

	for(var result of Query.search('omp')) {
		ompPragmas.push(result);
	}
	return ompPragmas;
}

function getObjFromCache(benchmark,  benchmarkGroup, problemSizeFlag, loopGroupSizeLimit, objectName) {
	var path = benchmark.cacheFolder + problemSizeFlag + "/" + objectName + "-" + loopGroupSizeLimit + ".json";
	var obj = Io.readJson(path);

	return obj;
}

function writeObjToCache(benchmark, benchmarkGroup, problemSizeFlag, loopGroupSizeLimit, objectName, obj) {
	var path = benchmark.cacheFolder + problemSizeFlag + "/" + objectName + "-" + loopGroupSizeLimit + ".json";
	Io.writeJson(path, obj);
}

function getLowestNestedLevel(loopGroup) {
	var lowestNestedId = loopGroup[0];
	var $loopJps = getLoopsFromIds(loopGroup);

	for(var loopId of loopGroup) {
		if($loopJps[loopId].nesteLevel < $loopJps[lowestNestedId].nesteLevel) {
			lowestNestedId = loopId;
		}
	}

	return lowestNestedId;
}