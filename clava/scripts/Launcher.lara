import ProgramAnalyzer;

import clava.Clava;
import lara.Io;

import lara.cmake.CMaker;
import lara.util.ProcessExecutor;

import weaver.WeaverJps;

aspectdef Launcher

	var mainParams = readParamsObj("mainParams");
	for(var paramToCreate of mainParams["paramsToCreate"]) {
		if(paramToCreate == "mainParams") {
			println("ERROR: " + paramToCreate + " is not a valid input for the field \"paramsToCreate\". Skipping this input.");
			continue;
		}

		createParamsObj(paramToCreate);
	}

	for(var paramToLoad of mainParams["paramsToLoad"]) {
		if(paramToLoad == "mainParams") {
			println("ERROR: " + paramToLoad + " is not a valid input for the field \"paramsToLoad\". Skipping this input.");
			continue;
		}

		var loadedParams = readParamsObj(paramToLoad);
		var now = new Date(Date.now());
		call ProgramAnalyzer(loadedParams, now);
	}
	
end


function createParamsObj(filename) {
	var params = {};

	params["benchGroupName"] = "";
	params["sourceFolder"] = "";
	params["benchmarkFolders"] = [];
	params["nRuns"] = 0;
	params["loopGroupSizeLimit"] = 0;
	params["functionFilters"] = [];
	params["problemSizeFlags"] = [];
	params["defaultFlag"] = "";
	params["allFolders"] = [];
	params["foldersToGetExpectedC"] = [];
	params["excludedFiles"] = [];
	params["excludedFolders"] = [];
	params["xtraFiles"] = [];
	params["xtraIncludeFolders"] = [];
	params["compilationFlags"] = [];
	params["compilationLibs"] = [];
	params["preprocessorFlags"] = [];
	
	params["clavaFlags"] = {};
	params["clavaFlags"]["testPragmas"] = 0;
	params["clavaFlags"]["readCache"] = false;
	params["clavaFlags"]["readFromExpectedOutput"] = false;
	params["clavaFlags"]["onlyCalculateCaches"] = false;
	params["clavaFlags"]["expressionBasedIterCounting"] = false;
	

	var path = "./params/" + filename + ".json";
	Io.writeJson(path, params);
}

function readParamsObj(filename) {
	var path = "./params/" + filename + ".json";
	var paramsObj = Io.readJson(path);

	return paramsObj;
}